= slide '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∏ –Ω–µ—â–∞' do
  p –í—Ç–æ—Ä–æ –¥–æ–º–∞—à–Ω–æ! –î–Ω–µ—Å!

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  list:
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ —Å `From`, `Into`
    Iterator (`Fibonacci`, `SentenceIterator` –≤—ä—Ä—Ö—É `TextInfo`)
    –ú–µ—Ç–æ–¥–∏ –Ω–∞ Iterator (`map`, `filter`, `fold`)
    –°–ø–µ—Ü–∏–∞–ª–Ω–∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏ (`ExactSizeIterator`, `DoubleEndedIterator`)
    `IntoIterator`, `for` —Ü–∏–∫–ª–∏

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'From' do
  example:
    impl From<Celsius> for Kelvin {
        fn from(t: Celsius) -> Kelvin {
            Kelvin(t.0 + 273.15)
        }
    }

= slide 'String parsing' do
  list:
    –ê–º–∏ –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ —Å—ä–∑–¥–∞–¥–µ–º –æ–±–µ–∫—Ç –æ—Ç –Ω–∏–∑?
    –ù–µ –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ `From`, –∑–∞—â–æ—Ç–æ –Ω–µ —Å–º–µ —Å–∏–≥—É—Ä–Ω–∏ —á–µ —Å—ä–∑–¥–∞–≤–∞–Ω–µ—Ç–æ —â–µ –µ —É—Å–ø–µ—à–Ω–æ
    –ò–º–∞ —Å–ø–µ—Ü–∏–∞–ª–µ–Ω trait –∑–∞ —Ç–æ–≤–∞

= slide 'String parsing', 'FromStr' do
  example:
    trait FromStr {
        type Err;

        fn from_str(s: &str) -> Result<Self, Self::Err>;
    }

    enum Result<T, E> {
        Ok(T),
        Err(E),
    }

  list:
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –æ—Ç –Ω–∏–∑ –¥–æ –Ω–∞—à —Å–∏ —Ç–∏–ø
    –í—Ä—ä—â–∞ `Result` –∫–æ–π—Ç–æ –ø–æ–∫–∞–∑–≤–∞ –¥–∞–ª–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –µ —É—Å–ø–µ—à–Ω–æ

= slide 'String parsing', 'FromStr' do
  example:
    use std::str::FromStr;

    let x = i32::from_str("-13");
    let y = u8::from_str("323");
    let z = f32::from_str("5e-3");


    println!("{:?} {:?} {:?}", x, y, z);  // ?

  pre.action
    ' Ok(-13)
      Err(ParseIntError { kind: Overflow })
      Ok(0.005)

= slide 'String parsing', 'parse' do
  p –ò–º–∞ –∏ –ø–æ-–µ—Ä–≥–æ–Ω–æ–º–∏—á–µ–Ω –Ω–∞—á–∏–Ω

  example:
    trait FromStr {
        type Err;
        fn from_str(s: &str) -> Result<Self, Self::Err>;
    }

    impl str {
        fn parse<F: FromStr>(&self) -> Result<F, <F as FromStr>::Err> { ... }
    }

  list:
    –ú–µ—Ç–æ–¥–∞ `parse` –µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω –≤—ä—Ä—Ö—É `str`
    –ú–µ—Ç–æ–¥–∞ `parse` –µ generic –ø–æ *return* —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ —Å–∏
    Generic –ø–∞—Ä–∞–º–µ—Ç—ä—Ä–∞ F —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ `FromStr` (–ø–æ–¥–æ–±–Ω–æ –Ω–∞ `Into` –∑–∞ `From`)
    –¢–∏–ø–∞ `<F as FromStr>::Err` –µ "—Ç–∏–ø–∞ `Err`, –∫–æ–π—Ç–æ –µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω –∑–∞ `FromStr` –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞ –Ω–∞ `F`"

= slide 'String parsing', 'parse' do
  example:
    let x = "-13".parse::<i32>();
    let y = "323".parse::<u8>();
    let z = "5e-3".parse::<f32>();

    println!("{:?} {:?} {:?}", x, y, z);

  pre.action
    ' Ok(-13)
      Err(ParseIntError { kind: Overflow })
      Ok(0.005)

= slide 'String parsing', 'parse' do
  example:
    use std::str::FromStr;

    #[derive(Debug)]
    struct Tardis {
        color: &'static str
    }

= slide 'String parsing', 'parse' do
  example:
    impl FromStr for Tardis {
        type Err = &'static str;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            if s == "blue" {
                Ok(Tardis { color: "blue" })
            } else {
                Err("Everyboy knows the TARDIS is blue!")
            }
        }
    }

= slide 'String parsing', 'parse' do
  example:
    fn main() {
        let t: Result<Tardis, <Tardis as FromStr>::Err> = "blue".parse();
        let x: Result<Tardis, <Tardis as FromStr>::Err> = "red".parse();

        println!("{:?}\n{:?}", t, x);
    }

    Ok(Tardis { color: "blue" })
    Err("Everyboy knows the TARDIS is blue!")

= slide 'String parsing', 'parse' do
  example:
    fn main() {
        let t = "blue".parse::<Tardis>();
        let x = "red".parse::<Tardis>();

        println!("{:?}\n{:?}", t, x);
    }

    Ok(Tardis { color: "blue" })
    Err("Everyboy knows the TARDIS is blue!")

= slide 'Error handling' do
  '

= slide 'Error handling' do
  example:
    use std::fs::File;
    use std::io::Read;

    fn main() {
        let mut file = File::open("deep_quotes.txt"); // Spoiler: –Ω—è–º–∞ –¥–∞ –≥–æ –±—ä–¥–µ

        let mut contents = String::new();
        file.read_to_string(&mut contents);

        println!("{}", contents);
    }

= slide 'Error handling' do
  ' <pre>
    error[E0599]: no method named `read_to_string` found for
    type `std::result::Result<std::fs::File, std::io::Error>` in the current scope
    --> src/main.rs:8:10
      |
    8 |     file.read_to_string(&mut contents);
      |          ^^^^^^^^^^^^^^
    </pre>

= slide 'Error handling' do
  example:
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }

    File::open("excellent_file.txt")
        // => Ok(std::fs::File)
    File::open("broken_file.txt")
        // => Err(std::io::Error)

= slide 'Error handling' do
  example:
    use std::fs::File;
    use std::io::Read;

    fn main() {
        let mut file = match File::open("deep_quotes.txt") {
            Ok(f) => f,
            Err(e) => panic!("OH, NO! {}", e),
        };

        let mut contents = String::new();
        file.read_to_string(&mut contents);
        println!("{}", contents);
    }

    // => Failure is just success rounded down, my friend!

= slide 'Error handling' do
  example:
    fn main() {
        let mut deep = match File::open("deep_quotes.txt") {
            Ok(f) => f,
            Err(e) => panic!("OH, NO! {}", e),
        };
        let mut wide = match File::open("wide_quotes.txt") {
            Ok(f) => f,
            Err(e) => panic!("OH, NO! {}", e),
        };

        let mut contents = String::new();
        deep.read_to_string(&mut contents);
        wide.read_to_string(&mut contents);
        println!("{}", contents);
    }

= slide 'Error handling' do
  example:
    fn main() {
        all_your_quotes_are_belong_to_us();
    }

    fn all_your_quotes_are_belong_to_us() {
        let mut deep = match File::open("deep_quotes.txt") {
            Ok(f) => f,
            Err(e) => panic!("OH, NO! {}", e),
        };
        let mut wide = match File::open("wide_quotes.txt") {
            Ok(f) => f,
            Err(e) => panic!("OH, NO! {}", e),
        };

        let mut contents = String::new();
        deep.read_to_string(&mut contents);
        wide.read_to_string(&mut contents);
        println!("{}", contents);
    }

= slide 'Error handling' do
  example:
    fn main() {
        match all_your_quotes_are_belong_to_us() {
            Ok(contents) => println!("{}", contents),
            Err(e) => panic!("OH, NO! {}", e),
        }
    }

    fn all_your_quotes_are_belong_to_us() -> Result<String, io::Error> {
        let mut deep = match File::open("deep_quotes.txt") {
            Ok(f) => f,
            Err(e) => return Err(e),
        };
        let mut wide = match File::open("wide_quotes.txt") {
            Ok(f) => f,
            Err(e) => return Err(e),
        };

        let mut contents = String::new();
        deep.read_to_string(&mut contents);
        wide.read_to_string(&mut contents);
        Ok(contents)
    }

= slide 'Error handling', 'A wild macro appears' do
  example:
    macro_rules! try {

        ($expr:expr) => {
            match $expr {
                Ok(result) => result,
                Err(e) => return Err(e),
            }
        }

    }

= slide 'Error handling' do
  example:
    fn main() {
        match all_your_quotes_are_belong_to_us() {
            Ok(contents) => println!("{}", contents),
            Err(e) => panic!("OH, NO! {}", e),
        }
    }

    fn all_your_quotes_are_belong_to_us() -> Result<String, io::Error> {
        let mut deep = try!(File::open("deep_quotes.txt"));
        let mut wide = try!(File::open("wide_quotes.txt"));

        let mut contents = String::new();
        deep.read_to_string(&mut contents);
        wide.read_to_string(&mut contents);

        Ok(contents)
    }

= slide 'Error handling' do
  ' <pre>
    warning: unused `std::result::Result` which must be used
      --> src/main.rs:16:5
       |
    16 |     deep.read_to_string(&mut contents);
       |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
       |
       = note: #[warn(unused_must_use)] on by default

    warning: unused `std::result::Result` which must be used
      --> src/main.rs:17:5
       |
    17 |     wide.read_to_string(&mut contents);
       |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
         Running `target/debug/scratch`
    </pre>

= slide 'Error handling' do
  example:
    fn main() {
        match all_your_quotes_are_belong_to_us() {
            Ok(contents) => println!("{}", contents),
            Err(e) => panic!("OH, NO! {}", e),
        }
    }

    fn all_your_quotes_are_belong_to_us() -> Result<String, io::Error> {
        let mut deep = try!(File::open("deep_quotes.txt"));
        let mut wide = try!(File::open("wide_quotes.txt"));

        let mut contents = String::new();
        try!(deep.read_to_string(&mut contents));
        try!(wide.read_to_string(&mut contents));

        Ok(contents)
    }

= slide 'Error handling', '–í—ä–ø—Ä–æ—Å' do
  example:
    // ??

    fn main() {
        try!(all_your_quotes_are_belong_to_us());
    }

= slide 'Error handling' do
  ' <pre>
    error[E0308]: mismatched types
     --> src/main.rs:5:5
      |
    5 |     try!(all_your_quotes_are_belong_to_us());
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum `std::result::Result`
      |
      = note: expected type `()`
                 found type `std::result::Result<_, _>`

= slide 'Error handling' do
  p –ê –∞–∫–æ –Ω–µ —Å–∞ –≤—Å–∏—á–∫–∏—Ç–µ –≥—Ä–µ—à–∫–∏ io::Error?

= slide 'Error handling' do
  example:
    fn all_your_numbers_are_belong_to_us() -> Result<i32, io::Error> {
        let mut numbers = try!(File::open("numbers.txt"));

        let mut contents = String::new();
        try!(numbers.read_to_string(&mut contents));

        let n =
            match contents.lines().next() {
                Some(first_line) => try!(first_line.parse::<i32>()),
                None => 0,
            };
        Ok(n)
    }

= slide 'Error handling' do
  ' <pre>
    error[E0308]: mismatched types
      --> src/main.rs:10:34
       |
    10 |             Err(e) => return Err(e),
       |                                  ^ expected struct `std::io::Error`,
                                            found struct `std::num::ParseIntError`
    ...
    47 |             try!(first_line.parse::&lt;i32&gt;())
       |             ------------------------------- in this macro invocation
       |
       = note: expected type `std::io::Error`
                  found type `std::num::ParseIntError`
    </pre>

= slide 'Error handling' do
  example:
    struct FancyError { message: String }

    impl From<io::Error> for FancyError {
        fn from(e: io::Error) -> Self {
            FancyError { message: format!("IO Error: {}", e) }
        }
    }

    impl From<num::ParseIntError> for FancyError {
        fn from(e: num::ParseIntError) -> Self {
            FancyError { message: format!("ParseError: {}", e) }
        }
    }

= slide 'Error handling' do
  example:
    macro_rules! try {

        ($expr:expr) => {
            match $expr {
                Ok(n) => n,
                //Err(e) => return Err(e),
                Err(e) => return Err(e.into()),
            }
        }

    }

= slide 'Error handling' do
  example:
    fn all_your_numbers_are_belong_to_us() -> Result<i32, FancyError> {
        let mut numbers = try!(File::open("numbers.txt"));

        let mut contents = String::new();
        try!(numbers.read_to_string(&mut contents));

        let n =
            match contents.lines().next() {
                Some(first_line) => try!(first_line.parse::<i32>()),
                None => 0,
            };

        Ok(n)
    }

= slide 'Error handling' do
  example:
    fn main() {
        match all_your_numbers_are_belong_to_us() {
            Ok(n) => println!("{}", n),
            Err(e) => panic!("OH, NO! {}", e.message),
        }
    }

= slide 'Error handling' do
  p –¢–≤—ä—Ä–¥–µ –º–Ω–æ–≥–æ —Å–∫–æ–±–∏ –∏ —É–¥–∏–≤–∏—Ç–µ–ª–Ω–∏. Also, deprecated.

  example:
    fn all_your_quotes_are_belong_to_us() -> Result<String, io::Error> {
        let mut deep = try!(File::open("deep_quotes.txt"));
        let mut wide = try!(File::open("wide_quotes.txt"));

        let mut contents = String::new();
        try!(deep.read_to_string(&mut contents));
        try!(wide.read_to_string(&mut contents));

        Ok(contents)
    }

= slide 'Error handling' do
  p –ò–º–∞ –ø–æ-–ø—Ä–æ—Å—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å:

  example:
    fn all_your_quotes_are_belong_to_us() -> Result<String, io::Error> {
        let mut deep = File::open("deep_quotes.txt")?;
        let mut wide = File::open("wide_quotes.txt")?;

        let mut contents = String::new();
        deep.read_to_string(&mut contents)?;
        wide.read_to_string(&mut contents)?;

        Ok(contents)
    }

= slide 'Error handling', '–º–µ—Ç–æ–¥–∏ –≤—ä—Ä—Ö—É Result' do
  example:
    let mut fun = File::open("fun.txt").
        or_else(|_| File::open("passable.txt")).
        or_else(|_| File::open("okay_i_guess.txt"))?;

= slide 'Error handling', '–º–µ—Ç–æ–¥–∏ –≤—ä—Ä—Ö—É Result' do
  example:
    let optional_fun = File::open("fun.txt").
        or_else(|_| File::open("passable.txt")).
        or_else(|_| File::open("okay_i_guess.txt"));

    if let Ok(mut fun) = optional_fun {
        // Super-special Fun Time!
    }

= slide 'Error handling', '–º–µ—Ç–æ–¥–∏ –≤—ä—Ä—Ö—É Result' do
  example:
    if let Err(_) = some_side_effects() {
        // –ï–¥–Ω–æ warning-—á–µ, –¥–∞ —Å–µ –∑–Ω–∞–µ...
    }

= slide 'Error handling', '–º–µ—Ç–æ–¥–∏ –≤—ä—Ä—Ö—É Result' do
  example:
    let number = "-13".parse::<i32>().unwrap();
    let number = "foo".parse::<i32>().unwrap(); // BOOM!

    let number = "-13".parse::<i32>().unwrap_or(0);
    let number = "foo".parse::<i32>().unwrap_or(0); // üëå

    let number = "foo".parse::<i32>().unwrap_or_else(|e| {
        println!("Warning: couldn't parse: {}", e);
        0
    });

= slide 'Panic' do
  list:
    –í–∏–∂–¥–∞–ª–∏ —Å–º–µ panic
    `panic!("something terrible happened")`
    `assert_eq!(1, 2)`
    `None.unwrap()`

= slide 'Panic', '–ö–∞–∫–≤–æ –ø—Ä–∞–≤–∏ –ø–∞–Ω–∏–∫–∞—Ç–∞' do
  list:
    —Ä–∞–±–æ—Ç–∏ –Ω–∞ –Ω–∏–≤–æ –Ω–∏—à–∫–∏
    —Ç–µ—Ä–º–∏–Ω–∏—Ä–∞ –Ω–∏—à–∫–∞—Ç–∞ –≤ –∫–æ—è—Ç–æ –µ –∏–∑–≤–∏–∫–∞–Ω–∞ –∏ –∏–∑–ø–∏—Å–≤–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ –∑–∞ –≥—Ä–µ—à–∫–∞
    unwind-–≤–∞ —Å—Ç–µ–∫–∞ (–ø–æ –ø–æ–¥—Ä–∞–∑–±–∏—Ä–∞–Ω–µ, –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–æ–º–µ–Ω—è –ø—Ä–∏ –∫–æ–º–ø–∏–ª–∞—Ü–∏—è)
    –ø—Ä–∏ –ø–∞–Ω–∏–∫–∞ –≤ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ —Å–µ –ø—Ä–µ–∫—Ä–∞—Ç—è–≤–∞ —Ü—è–ª–∞—Ç–∞ –ø—Ä–æ–≥—Ä–∞–º–∞

  p

  list:
    –ø–∞–Ω–∏–∫–∏—Ç–µ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç —Ö–≤–∞–Ω–∞—Ç–∏ (–Ω—è–º–∞ catch)
    –¥–æ–±—Ä–µ –¥–µ –º–æ–≥–∞—Ç, –Ω–æ —Ç–æ–≤–∞ –µ –º–Ω–æ–≥–æ —á–∞—Å—Ç–µ–Ω —Å–ª—É—á–∞–π –∏ –Ω–µ —Å–∞ –ø—Ä–µ–¥–≤–∏–¥–µ–Ω–∏ –∑–∞ —Ç–æ–≤–∞

= slide 'Panic', '–ö–æ–≥–∞?' do
  list:
    –≥—Ä–µ—à–∫–∏ –≤ –ª–æ–≥–∏–∫–∞—Ç–∞ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞
    –∏–ª–∏ –ø—Ä–∏ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
    –∫–æ–∏—Ç–æ –Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç user input
    –∏ –Ω—è–º–∞ —Å–º–∏—Å—ä–ª –¥–∞ —Å–µ –æ–ø–∏—Ç–∞–º–µ –¥–∞ —Å–µ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤–∏–º –æ—Ç —Ç—è—Ö

  p

  list:
    —Ç–µ—Å—Ç–æ–≤–µ
    –ø—Ä–∏–º–µ—Ä–∏
    rapid prototyping

= slide 'Error handling', '–û–±–æ–±—â–µ–Ω–∏–µ' do
  p –ì—Ä–µ—à–∫–∏—Ç–µ –≤ rust —Å–µ —Ä–∞–∑–¥–µ–ª—è—Ç –Ω–∞ –¥–≤–∞ –≤–∏–¥–∞
  list:
    —Ç–∞–∫–∏–≤–∞ –æ—Ç –∫–æ–∏—Ç–æ –º–æ–∂–µ–º –¥–∞ —Å–µ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤–∏–º - `Result`, `Option`, etc
    —Ç–∞–∫–∏–≤–∞ –æ—Ç –∫–æ–∏—Ç–æ –Ω–µ –º–æ–∂–µ–º –¥–∞ —Å–µ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤–∏–º - `panic!`
    –Ω—è–º–∞ exceptions!

= slide 'Read & Write' do
  p –ò–º–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ —Ç–∏–ø–∞–∂–∏, –∫–æ–∏—Ç–æ –Ω–∏ –ø–æ–º–∞–≥–∞—Ç –∑–∞ —á–µ—Ç–µ–Ω–µ –∏ –ø–∏—Å–∞–Ω–µ

= slide 'Read & Write', 'Read' do
  p –ï–¥–∏–Ω –æ—Ç —Ç—è—Ö –µ <code>Read</code>

  example:
    pub trait Read {
        fn read(&mut self, buf: &mut [u8]) -> Result<usize>;

        unsafe fn initializer(&self) -> Initializer { ... }
        fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> { ... }
        fn read_to_string(&mut self, buf: &mut String) -> Result<usize> { ... }
        fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> { ... }
        fn by_ref(&mut self) -> &mut Self where Self: Sized { ... }
        fn bytes(self) -> Bytes<Self> where Self: Sized { ... }
        fn chars(self) -> Chars<Self> where Self: Sized { ... }
        fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized { ... }
        fn take(self, limit: u64) -> Take<Self> where Self: Sized { ... }
    }

= slide 'Read' do
  p –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ —Å–µ –∑–∞ –Ω—è–∫–æ–∏ –æ—á–∞–∫–≤–∞–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏

  example:
    impl Read for File
    impl Read for Stdin
    impl Read for TcpStream

= slide 'Read' do
  p –í–∏–¥—è—Ö–º–µ –∫–∞–∫ –º–æ–∂–µ –¥–∞ —á–µ—Ç–µ–º –æ—Ç —Ñ–∞–π–ª, –∞ —Å–µ–≥–∞ –∏ –æ—Ç Stdin

  example:
    use std::io::{self, Read};

    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

= slide 'Read & Write', 'Write' do
  p –ó–∞ –ø–∏—Å–∞–Ω–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ <code>Write</code>

  example:
    pub trait Write {
        fn write(&mut self, buf: &[u8]) -> Result<usize>;
        fn flush(&mut self) -> Result<()>;

        fn write_all(&mut self, buf: &[u8]) -> Result<()> { ... }
        fn write_fmt(&mut self, fmt: Arguments) -> Result<()> { ... }
        fn by_ref(&mut self) -> &mut Self where Self: Sized { ... }
    }

= slide 'Write' do
  p –ö–∞–∫—Ç–æ <code>Read</code> —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –∑–∞ –æ—á–∞–∫–≤–∞–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏

  example:
    impl Write for File
    impl Write for Stdout
    impl Write for Stderr
    impl Write for TcpStream
    impl Write for Vec<u8>

= slide 'Write' do
  example:
    use std::fs::File;
    use std::io::Write;

    let mut f = File::create("foo.txt")?;
    f.write_all(b"Hello, world!")?;

= slide 'Read & Write' do
  p –ö–∞—Ç–æ —Ü—è–ª–æ —Å–∞ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–∏, –Ω–æ –Ω–µ –≤–∏–Ω–∞–≥–∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏ –∫–æ–≥–∞—Ç–æ –ø—Ä–∞–≤–∏–º –º–Ω–æ–≥–æ, –Ω–æ –º–∞–ª–∫–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏

= slide 'BufReader & BufWriter' do
  list:
    –ó–∞—Ç–æ–≤–∞ —Å–∞ —Å—ä–∑–¥–∞–¥–µ–Ω–∏ <code>BufReader</code> –∏ <code>BufWriter</code>
    –ò–∑–ø–æ–ª–∑–≤–∞—Ç —Å–µ –¥–∞ –±—É—Ñ–µ—Ä–∏—Ä–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏—Ç–µ, –∫–∞–∫—Ç–æ —Å–µ –¥–æ—Å–µ—â–∞—Ç–µ –æ—Ç –∏–º–µ–Ω–∞—Ç–∞ –∏–º

= slide 'BufReader & BufWriter', 'BufReader' do
  p <code>BufReader</code> –µ wrapper –∑–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏, –∫–æ–∏—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç <code>Read</code>

  example:
    use std::io::prelude::*;
    use std::io::BufReader;
    use std::fs::File;

    let f = File::open("log.txt")?;
    let mut reader = BufReader::new(f);

    let mut line = String::new();
    let len = reader.read_line(&mut line)?;
    println!("First line is {} bytes long", len);

= slide 'BufReader & BufWriter', 'BufReader' do
  p –¢—É–∫ —Å–µ –ø–æ—è–≤—è–≤–∞ –Ω–æ–≤ –º–µ—Ç–æ–¥ <code>read_line</code>

= slide 'BufReader & BufWriter', 'BufRead' do
  p –ï—Ç–æ –æ—Ç –∫—ä–¥–µ

  example:
    pub trait BufRead: Read {
        fn fill_buf(&mut self) -> Result<&[u8]>;
        fn consume(&mut self, amt: usize);

        fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> { ... }
        fn read_line(&mut self, buf: &mut String) -> Result<usize> { ... }
        fn split(self, byte: u8) -> Split<Self> where Self: Sized { ... }
        fn lines(self) -> Lines<Self> where Self: Sized { ... }
    }

= slide 'BufReader & BufWriter', 'BufWriter' do
  p –ü–æ–¥–æ–±–Ω–æ, <code>BufWriter</code> –µ wrapper –∑–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏, –∫–æ–∏—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç <code>Write</code>

  example:
    use std::io::prelude::*;
    use std::io::BufWriter;
    use std::net::TcpStream;

    let mut stream = BufWriter::new(TcpStream::connect("127.0.0.1:34254").unwrap());

    for i in 1..10 {
        stream.write(&[i]).unwrap();
    }

  p –í —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä —á—Ä–µ–∑ <code>BufWriter</code> –ø—Ä–µ–≤—Ä—ä—â–∞–º–µ 10 system calls –≤ 1

= slide 'BufReader & BufWriter', 'BufWrite' do
  p –°–æ—Ä–∏, –Ω—è–º–∞ <code>BufWrite</code> :(

= slide 'Read & Write' do
  p –î–æ–±—Ä–µ –¥–µ, —Ç–æ–≤–∞ –ª–∏ –µ –≤—Å–∏—á–∫–æ?

= slide 'Read & Write' do
  p –ù–µ

= slide 'Read & Write' do
  p <code>Write</code> –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –∏ –∑–∞ —Ç–µ—Å—Ç–≤–∞–Ω–µ —á—Ä–µ–∑ <code>mock</code>

  example:
    // –ü—Ä–µ–¥—Å—Ç–∞–≤–µ—Ç–µ —Å–∏, —á–µ –ø–∏—à–µ–º u32 –∏ —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω–µ –µ —Ç–æ–ª–∫–æ–≤–∞ –±–µ–∑–ø–æ–ª–µ–∑–Ω–∞
    fn write_u8<W>(writer: &mut W, data: u8) -> io::Result<usize> where W: Write {
        writer.write(&[data])
    }

    #[test]
    fn test_write_u8() {
        let mut mock: Vec<u8> = Vec::new();

        write_u8(&mut mock, 42).unwrap();

        assert_eq!(mock.len(), 1);
        assert_eq!(mock[0], 42);
    }

= slide 'Any' do
  example:
    use std::any::Any;

    let s = String::from("foo");
    let v: Vec<&Any> = vec![&10_i32, &s, &1.23];

    for elem in v {
        if let Some(num) = elem.downcast_ref::<i32>() {
            println!("number: {}", num);
        }
        else if let Some(s) = elem.downcast_ref::<String>() {
            println!("string: {}", s);
        }
        else {
            println!("unknown: {:?}", elem);
        }
    }
