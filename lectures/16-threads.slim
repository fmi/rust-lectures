= slide '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∏ –Ω–µ—â–∞' do
  list:
    –¢—Ä–µ—Ç–æ –¥–æ–º–∞—à–Ω–æ!

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  list:
    –ü—Ä–µ–≥–æ–≤–æ—Ä –Ω–∞ –≤—Ç–æ—Ä–æ –¥–æ–º–∞—à–Ω–æ, —Å –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏
    –§—É–Ω–∫—Ü–∏–∏ –∏ —Ç–µ—Ö–Ω–∏—Ç–µ —Ç–∏–ø–æ–≤–µ
    Closure-–∏

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  p –ú–∏–Ω–∞–ª–∏—è—Ç –ø—ä—Ç –º–∞–ª–∫–æ –≤–∏ –∏–∑–ª—ä–≥–∞—Ö–º–µ –∑–∞ closures

  p –ö–∞–∫ —Å–µ –ø—Ä–∏—Ö–≤–∞—â–∞—Ç –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏ –æ—Ç —Ç–æ–≤–∞ –∫–∞–∫ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç

  example:
    let nums = vec![0, 1, 2, 3];

    // –ø—Ä–∏—Ö–≤–∞—â–∞ `nums` –∫–∞—Ç–æ `&Vec<i32>`
    let f1 = || {
        for n in &nums {
            println!("{}", n);
        }
    };

    // –ø—Ä–∏—Ö–≤–∞—â–∞ `nums` –∫–∞—Ç–æ `Vec<i32>`
    let f2 = || {
        for n in nums {
            println!("{}", n);
        }
    };

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  p <code>move</code> –ø—Ä–µ–º–µ—Å—Ç–≤–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –∫–∞–∫ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞

  example:
    let nums = vec![0, 1, 2, 3];

    // –ø—Ä–∏—Ö–≤–∞—â–∞ `nums` –∫–∞—Ç–æ `Vec<i32>`
    let f3 = move || {
        for n in &nums {
            println!("{}", n);
        }
    };

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  p –ù—è–∫–æ–ª–∫–æ —Ç—Ä–∏–∫–∞ –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –ø—Ä–µ–º–µ—Å—Ç–∏–º –Ω—è–∫–æ—è —Å—Ç–æ–π–Ω–æ—Å—Ç, –Ω–æ –¥–∞ –ø—Ä–∏—Ö–≤–∞–Ω–µ–º –¥—Ä—É–≥–∞ –ø–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è

  example:
    let nums = vec![0, 1, 2, 3];
    let s = String::from("–±–∞–±–∞");

    let f = || {
        let nums = nums;        // move `nums`

        println!("{:?}", nums);
        println!("{:?}", s);
    };

    // println!("{:?}", nums);   // –∫–æ–º–ø. –≥—Ä–µ—à–∫–∞
    println!("{:?}", s);

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  example:
    let nums = vec![0, 1, 2, 3];
    let s = String::from("–±–∞–±–∞");

    {
        let s = &s;             // move `s: &String`

        let f = move || {
            println!("{:?}", nums);
            println!("{:?}", s);
        };
    }

    // println!("{:?}", nums);   // –∫–æ–º–ø. –≥—Ä–µ—à–∫–∞
    println!("{:?}", s);

= slide 'Event emitter' do
  p –ú–∏–Ω–∞–ª–∏—è—Ç –ø—ä—Ç –Ω–∞–ø–∏—Å–∞—Ö–º–µ –ø—Ä–æ—Å—Ç event emitter
  p –î–∞ —Å–∏ –ø—Ä–∏–ø–æ–º–Ω–∏–º –∫–∞–∫—ä–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–º–∞—à–µ

= slide 'Event emitter' do
  example:
    struct EventEmitter<E, P> where E: Eq + Hash, P: Clone {
        next_id: Id,
        map: HashMap<E, Vec<Listener<P>>>
    }

    impl<E, P> EventEmitter<E, P> where E: Eq + Hash, P: Clone {
        fn new() -> Self { ... }

        /// –†–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞ —Å–ª—É—à–∞—Ç–µ–ª
        fn on<F>(&mut self, event: E, listener: F) -> Id where F: Fn(P) + 'static { ... }

        /// –ü—Ä–µ–º–∞—Ö–≤–∞ —Å–ª—É—à–∞—Ç–µ–ª
        fn off(&mut self, id: Id) -> bool { ... }

        /// –ò–∑–ª—ä—á–≤–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ —Å –¥–∞–Ω–Ω–∏
        fn emit<B>(&self, event: B, payload: P) -> bool where B: Borrow<E> { ... }
    }

= slide 'Event emitter' do
  example:
    type Id = u64;

    struct Listener<P> {
        id: Id,
        closure: Box<Fn(P) + 'static>
    }

    impl<P> Listener<P> {
        fn new<F>(id: Id, f: F) -> Self where F: Fn(P) + 'static { ... }
    }

= slide 'Event emitter' do
  p
    ' –¢–∞–∑–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –∏–º–∞—à–µ –ø—Ä–æ–±–ª–µ–º - –∫–∞–∫–≤–æ —Å—Ç–∞–≤–∞ –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –ø–æ–¥–∞–¥–µ–º
      –¥–∞–Ω–Ω–∏—Ç–µ –∑–∞ —Å—ä–æ–±—â–µ–Ω–∏–µ—Ç–æ –ø—Ä–µ–∑ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è

  example:
    fn main() {
        let mut emitter = EventEmitter::new();
        emitter.on("boot", |p: &str| println!("{}", p));

        let data = "woot".to_string();
        emitter.emit("boot", &data);
    }

= slide 'Event emitter' do
  pre
    ' error[E0597]: `data` does not live long enough
        --> src/main.rs:177:1
          |
      176 |     emitter.emit("boot", &data);
          |                           ---- borrow occurs here
      177 | }
          | ^ `data` dropped here while still borrowed
          |
          = note: values in a scope are dropped in the opposite order they are created

  p.action –ó–∞—â–æ?

= slide 'Event emitter' do
  p –û—â–µ –ø–æ-—Å—Ç—Ä–∞–Ω–Ω–æ, –∞–∫–æ –ø—Ä–µ–º–µ—Å—Ç–∏–º <code>data</code> –Ω–∞–¥ <code>emitter</code>, –≤—Å–∏—á–∫–æ —Ä–∞–±–æ—Ç–∏

  example:
    fn main() {
        let data = "woot".to_string();

        let mut emitter = EventEmitter::new();
        emitter.on("boot", |p: &str| println!("{}", p));

        emitter.emit("boot", &data);
    }

= slide 'Event emitter' do
  p <code>emitter</code> –Ω—è–º–∞ lifetime, –Ω–æ –∏—Å–∫–∞ –¥–∞ –∂–∏–≤–µ–µ –ø–æ–≤–µ—á–µ –æ—Ç <code>data</code>...
  p.action ... –∞ –¥–∞–ª–∏ –µ —Ç–∞–∫–∞?

= slide 'Event emitter' do
  example:
    emitter.emit("boot", &data);

    fn emit<B>(&self, event: B, payload: P) -> bool where B: Borrow<E> { ... }

    // => P = &'a str

= slide 'Event emitter' do
  example:
    fn main() {
        let mut emitter = EventEmitter::new();            // EventEmitter<E = ?, P = ?>
        emitter.on("boot", |p: &str| println!("{}", p));  // EventEmitter<&'static str, &'? str>

        let data = "woot".to_string();
        emitter.emit("boot", &data);                      // EventEmitter<&'static str, &'a str>
    }

  p <code>P</code> –æ–≥—Ä–∞–Ω–∏—á–∞–≤–∞ –∫–æ–ª–∫–æ –º–æ–∂–µ –¥–∞ –∂–∏–≤–µ–µ <code>emitter</code>

= slide 'Event emitter' do
  p –†–µ—à–µ–Ω–∏–µ—Ç–æ: <code>P</code> -> <code>&P</code>

  example:
      fn emit<B>(&self, event: B, payload: &P) -> bool where B: Borrow<E> { ... }

      struct Listener<P> {
          id: Id,
          closure: Box<Fn(&P) + 'static>
      }

= slide 'Event emitter' do
  pre
    ' error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied
        --> src/main.rs:175:13
          |
      175 |     emitter.on("boot", |p: &str| println!("{}", p));
          |             ^^ `str` does not have a constant size known at compile-time
          |
          = help: the trait `std::marker::Sized` is not implemented for `str`

= slide 'Event emitter' do
  p
    ' –ò–∑–ø–æ–ª–∑–≤–∞–º–µ <code>P</code> —Å–∞–º–æ –∑–∞–¥ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è (<code>&P</code>) –∑–∞—Ç–æ–≤–∞ –º–æ–∂–µ–º –¥–∞
      –¥–æ–±–∞–≤–∏–º "–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ" <code>?Sized</code>

  example:
    struct Listener<P> where P: ?Sized {
        id: Id,
        closure: Box<Fn(&P) + 'static>
    }

    struct EventEmitter<E, P> where E: Eq + Hash, P: ?Sized {
        next_id: Id,
        map: HashMap<E, Vec<Listener<P>>>
    }

= slide 'Event emitter' do
  pre
    ' woot

  p –†–∞–±–æ—Ç–∏!

= slide 'Closures', '–ê—Ä–≥—É–º–µ–Ω—Ç–∏ —Å lifetime' do
  list:
    `Box<Fn(&P) + 'static>`
    –∫–∞–∫–≤–æ –µ `Fn(&P)`?
    —è–≤–Ω–æ –µ lifetime elision, –Ω–æ –∫–∞–∫–≤–∞ –µ –ø—ä–ª–Ω–∞—Ç–∞ –≤–µ—Ä—Å–∏—è?

= slide 'Closures', '–ê—Ä–≥—É–º–µ–Ω—Ç–∏ —Å lifetime' do
  list:
    `for<'a> Fn(&'a P)`

= slide 'Fearless concurrency' do
  img src="images/time_travel.jpg"

= slide '–ù–∏—à–∫–∏' do
  example:
    use std::thread;

    fn main() {
        thread::spawn(|| println!("hi from the spawned thread"));

        println!("hi from the main thread");
    }

  p.action
    ' –ü—Ä–∏–º–µ—Ä–µ–Ω –∏–∑—Ö–æ–¥

  pre.action
    ' hi from the main thread

= slide '–ù–∏—à–∫–∏' do
  p –ü—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –ø—Ä–∏–∫–ª—é—á–≤–∞ –∫–æ–≥–∞—Ç–æ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ –∑–∞–≤—ä—Ä—à–∏

  example:
    use std::thread;

    fn main() {
        let handle = thread::spawn(|| println!("hi from the spawned thread"));

        println!("hi from the main thread");
        handle.join();
    }

  pre
    ' hi from the main thread
      hi from the spawned thread

= slide '–ù–∏—à–∫–∏' do
  example:
    use std::thread;

    fn main() {
        let nums = (0..100).collect::<Vec<_>>();

        let handle = thread::spawn(|| {
            for i in &nums {
                println!("number {} from the spawned thread", i);
            }
        });

        handle.join();
    }

= slide '–ù–∏—à–∫–∏' do
  pre
    ' error[E0373]: closure may outlive the current function, but it borrows `nums`, which is owned
                    by the current function
      --> src/main.rs:6:36
        |
      6 |         let handle = thread::spawn(|| {
        |                                    ^^ may outlive borrowed value `nums`
      7 |             for i in &nums {
        |                       ---- `nums` is borrowed here
        |
      help: to force the closure to take ownership of `nums` (and any other referenced variables),
            use the `move` keyword
        |
      6 |         let handle = thread::spawn(move || {
        |                                    ^^^^^^^

= slide '–ù–∏—à–∫–∏' do
  example:
    pub fn spawn<F, T>(f: F) -> JoinHandle<T> where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static,

  list:
    –ù—è–º–∞–º–µ –≥–∞—Ä–∞–Ω—Ü–∏–∏ –∫–æ–ª–∫–æ –≤—Ä–µ–º–µ —â–µ –∂–∏–≤–µ–µ –Ω–∏—à–∫–∞—Ç–∞, –∑–∞—Ç–æ–≤–∞ –Ω–µ –º–æ–∂–µ–º –¥–∞ –∏–∑–ø—Ä–∞—â–∞–º–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
    –©–µ –≤–∏–¥–∏–º –∫–∞–∫–≤–æ –µ `Send` —Å–ª–µ–¥ –º–∞–ª–∫–æ

= slide '–ù–∏—à–∫–∏' do
  example:
    use std::thread::Builder;

    let nums = (0..100).collect::<Vec<_>>();

    let handle = Builder::new()
        .name("sirespawn".to_string())
        .spawn(move || {
            for i in &nums {
                println!("number {} from the spawned thread", i);
            }
            nums
        })
        .expect("could not create thread");

    let nums = handle.join().expect("sirespawn panicked!");
    println!("{:?}", nums);

= slide '–ù–∏—à–∫–∏' do
  example:
    use std::thread;
    use std::time::Duration;

    let handle = thread::spawn(|| {
        println!("before park");
        thread::park();
        println!("after park");
    });

    thread::sleep(Duration::from_secs(1));
    handle.thread().unpark();
    let _ = handle.join();

= slide 'Send + Sync' do
  p Send - –ø–æ–∑–≤–æ–ª—è–≤–∞ –ø—Ä–µ—Ö–≤—ä—Ä–ª—è–Ω–µ –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–æ—Å—Ç –º–µ–∂–¥—É –Ω–∏—à–∫–∏
  p Sync - –ø–æ–∑–≤–æ–ª—è–≤–∞ —Å–ø–æ–¥–µ–ª—è–Ω–µ –º–µ–∂–¥—É –Ω—è–∫–æ–ª–∫–æ –Ω–∏—à–∫–∏ –ø—Ä–µ–∑ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è <code>&T</code>

  list:
    marker traits
    –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω–∏ —Å–∞ –∑–∞ –ø–æ–≤–µ—á–µ—Ç–æ —Ç–∏–ø–æ–≤–µ
    –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç —Å–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∞–∫–æ –≤—Å–∏—á–∫–∏—Ç–µ –Ω–∏ –ø–æ–ª–µ—Ç–∞ —Å–∞ —Å—ä–æ—Ç–≤–µ—Ç–Ω–æ `Send` –∏ `Sync`
    unsafe traits - `unsafe` —Å–∞ –∑–∞ —Ä—ä—á–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è

= slide 'Send + Sync', 'Send' do
  list:
    –ø—Ä–∏–º–µ—Ä –∑–∞ —Ç–∏–ø–æ–≤–µ, –∫–æ–∏—Ç–æ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –ø—Ä–µ—Ö–≤—ä—Ä–ª—è—Ç –º–µ–∂–¥—É –Ω–∏—à–∫–∏
    `Rc`
    `Weak`
    `*const T`
    `*mut T`
    –∏ –¥—Ä—É–≥–∏

= slide 'Send + Sync', 'Sync' do
  list:
    —Ç–∏–ø–æ–≤–µ –∫–æ–∏—Ç–æ –Ω–µ —Å–∞ `Sync` –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –∏–º–∞—Ç internal mutability –±–µ–∑ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è, –Ω–∞–ø—Ä–∏–º–µ—Ä
    `Cell`
    `RefCell`
    `Rc`
    `Weak`
    `*const T`
    `*mut T`

= slide 'Send + Sync', '–∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è' do
  example:
    struct MyBox(*mut u8);

    unsafe impl Send for MyBox {}
    unsafe impl Sync for MyBox {}

= slide 'Send + Sync', '–¥–µ–∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è' do
  example:
    // –°–∞–º–æ –Ω–∞ nightly
    #![feature(optin_builtin_traits)]

    struct SpecialToken(u8);

    impl !Send for SpecialToken {}
    impl !Sync for SpecialToken {}

  list:
    –∑–∞–±—Ä–∞–Ω—è–≤–∞–º–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞—Ç–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ `Send` –∏ `Sync`
    –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞—Ç–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∏–∫–æ–≥–∞ –Ω—è–º–∞ –¥–∞ –µ –≥—Ä–µ—à–Ω–∞ –æ—Ç —Å–∞–º–æ —Å–µ–±–µ —Å–∏
    –Ω–æ –º–æ–∂–µ –¥–∞ –ø–∏—à–µ–º –∫–æ–¥, –∫–æ–π—Ç–æ —Ä–∞–∑—á–∏—Ç–∞, —á–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø –Ω–µ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–µ—Ö–≤—ä—Ä–ª—è / —Å–ø–æ–¥–µ–ª—è

= slide 'Send + Sync', '–¥–µ–∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è' do
  p –•–∞–∫ –∞–∫–æ –Ω–µ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ nightly rust

  example:
    use std::marker::PhantomData;

    struct SpecialToken(u8, PhantomData<*const ()>);

  list:
    `PhantomData<T>` –µ —Å–ø–µ—Ü–∏–∞–ª–µ–Ω —Ç–∏–ø –∑–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞
    –Ω—è–º–∞ —Ä–∞–∑–º–µ—Ä (zero sized type)
    –∫–∞—Ä–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ –¥–∞ —Å–µ –¥—ä—Ä–∂–∏ –≤—Å–µ –µ–¥–Ω–æ —Å—ä–¥—ä—Ä–∂–∞ `T`

= slide 'Arc' do
  list:
    Atomic Reference Counter
    –ø–æ–¥–æ–±–Ω–æ –Ω–∞ `Rc`, –Ω–æ –∏–∑–ø–æ–ª–∑–≤–∞ –∞—Ç–æ–º–∞—Ä–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏
    –ø–æ–∑–≤–æ–ª—è–≤–∞ —Å–ø–æ–¥–µ–ª—è–Ω–µ –º–µ–∂–¥—É –Ω–∏—à–∫–∏ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∏, –∫–æ–∏—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç `Send` –∏ `Sync`
    –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∏ –¥–∞ –≤–∑–µ–º–µ–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è (`&T`) –∫—ä–º —Å—ä–¥—ä—Ä–∂–∞–Ω–∏–µ—Ç–æ
    –∏–º–∞ –∏ —Å–ª–∞–±–∞ –≤–µ—Ä—Å–∏—è - `std::sync::Weak`

= slide 'Arc' do
  example:
    use std::sync::Arc;
    use std::thread;

    fn main() {
        let shared = Arc::new(123);

        for _ in 0..3 {
            let shared = Arc::clone(&shared);

            thread::spawn(move || {
                let data = *shared;
                println!("{}", data)
            });
        }
    }

= slide 'Mutex' do
  example:
    use std::sync::Mutex;

    fn main() {
        let mutex = Mutex::new(10);

        {
            // lock the mutex
            // `lock` is a smart pointer which derefs to `&T` and `&mut T`
            let mut lock = mutex.lock().unwrap();

            *lock += 32;

            // mutex is unlocked when `lock` is dropped (`lock` is a RAII guard)
        }
    }

= slide '–î—Ä—É–≥–∏' do
  list:
    –¥—Ä—É–≥–∏ —Ç–∏–ø–æ–≤–µ –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤–∫–ª—é—á–≤–∞—Ç
    `RwLock`
    `Condvar`
    `Barrier`
    –≤–∏–∂—Ç–µ `std::sync`

= slide 'Event emitter' do
  p
    ' –ó–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ —â–µ —Ä–∞–∑—à–∏—Ä–∏–º event emitter-–∞ –æ—Ç –º–∏–Ω–∞–ª–∞—Ç–∞ –ª–µ–∫—Ü–∏—è —Ç–∞–∫–∞, —á–µ –¥–∞ –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞
      –æ—Ç –º–Ω–æ–≥–æ –Ω–∏—à–∫–∏

  example:
    impl<E, P> EventEmitter<E, P> where E: Eq + Hash {
        fn new() -> Arc<Mutex<Self>> {
            Arc::new(Mutex::new(Self {
                next_id: Id::default(),
                map: HashMap::new()
            }))
        }
    }

= slide 'panic' do
  list:
    `panic!` –≤ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏—à–∫–∞ —Å–ø–∏—Ä–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞
    `panic!` –≤ –¥—Ä—É–≥–∞ –Ω–∏—à–∫–∞ —Å–ø–∏—Ä–∞ –Ω–∏—à–∫–∞—Ç–∞
    `JoinHandle::join` —â–µ –Ω–∏ –≤—ä—Ä–Ω–µ –¥–∞–ª–∏ –Ω–∏—à–∫–∞—Ç–∞ —Å–µ –µ –ø–∞–Ω–∏—Ä–∞–ª–∞
    –∞–∫–æ –µ —Ç–∞–∫–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ —â–µ –µ `Err(Box<Any + Send + 'static>)`

= slide 'panic' do
  list:
    –∞–∫–æ –Ω–∏—à–∫–∞ –µ –∑–∞–∫–ª—é—á–∏–ª–∞ mutex –∏ —Å–µ –ø–∞–Ω–∏—Ä–∞ –ø–æ —Ç–æ–≤–∞ –≤—Ä–µ–º–µ, –º–æ–∂–µ –¥–∞–Ω–Ω–∏—Ç–µ –ø–∞–∑–µ–Ω–∏ –æ—Ç mutex-–∞ –¥–∞ —Å–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω–∏
    –≤ —Ç–∞–∫—ä–≤ —Å–ª—É—á–∞–π mutex-–∞ —Å–µ –∑–∞—á–∏—Ç–∞ –∑–∞ –æ—Ç—Ä–æ–≤–µ–Ω (mutex poisoning)
    `Mutex::lock()` –∏ `Mutex::try_lock()` –≤—Ä—ä—â–∞—Ç —Ä–µ–∑—É–ª—Ç–∞—Ç
    –∏–ª–∏ `Ok(MutexGuard)` –ø—Ä–µ–∑ –∫–æ–π—Ç–æ –º–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç—ä–ø–≤–∞–º–µ –≤—ä—Ç—Ä–µ—à–Ω–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
    –∏–ª–∏ `Err(PoisonError)` –∞–∫–æ mutex-–∞ –µ –æ—Ç—Ä–æ–≤–µ–Ω

= slide 'Atomics' do
  p –°—ä—â–µ—Å—Ç–≤—É–≤–∞—Ç –∏ –∞—Ç–æ–º–∞—Ä–Ω–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ —Ç–∏–ø–æ–≤–µ

  list:
    –ø–æ–ª–∑–≤–∞—Ç —Å–µ –æ—Ç `Arc` –Ω–∞–ø—Ä–∏–º–µ—Ä
    AtomicBool
    AtomicUsize
    ...

= slide 'Atomics' do
  example:
    use std::sync::atomic::{AtomicIsize, Ordering};

    let some_isize = AtomicIsize::new(5);

    some_isize.store(10, Ordering::Relaxed);
    assert_eq!(some_isize.load(Ordering::Relaxed), 10);

= slide 'Atomics' do
  p –ö–∞–∫–≤–æ –ø—Ä–∞–≤–∏ <code>Ordering</code>?

  example:
    pub enum Ordering {
      Relaxed,
      SeqCst,
      // some variants omitted
    }

  list:
    –∫–∞–∑–≤–∞ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ –∫–∞–∫–≤–æ –º–æ–∂–µ –¥–∞ –ø—Ä–∞–≤–∏ —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏—Ç–µ –æ–∫–æ–ª–æ –æ–ø–µ—Ä–∞—Ü–∏—è—Ç–∞
    –≤–∞—Ä–∏–∞–Ω—Ç–∏—Ç–µ —Å–∞ —Å—ä—â–∏—Ç–µ –∫–∞—Ç–æ –Ω–∞ LLVM
    `Relaxed` –µ –≤ —Å–ª—É—á–∞–π –∫–æ–≥–∞—Ç–æ –Ω—è–º–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ –º–æ–∂–µ –¥–∞ —Ä–∞–∑–º–µ—Å—Ç–≤–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏—Ç–µ

  p.action
    ' `SeqCst` (sequentially consistent) –Ω–µ –ø–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∏—Ç–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∑–∞ —á–µ—Ç–µ–Ω–µ –Ω–∏—Ç–æ –∑–∞ –ø–∏—Å–∞–Ω–µ
      –¥–∞ –±—ä–¥–∞—Ç —Ä–∞–∑–º–µ—Å—Ç–≤–∞–Ω–∏ –Ω–∏—Ç–æ –ø—Ä–µ–¥–∏, –Ω–∏—Ç–æ —Å–ª–µ–¥ —Ä–µ–¥–∞ —Å –Ω–∞—à–∞—Ç–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è.

= slide 'Atomics' do
  p
    ' –ò–º–∞ –∏ —Ä–∞–∑–Ω–∏ –ø–æ–ª–µ–∑–Ω–∏ –º–µ—Ç–æ–¥–∏ –∫–∞—Ç–æ <code>compare_and_swap</code>, –Ω–æ –æ—Å—Ç–∞–≤—è–º–µ –Ω–∞ –≤–∞—Å
      –¥–∞ —Å–∏ —á–µ—Ç–µ—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞, –∞–∫–æ —â–µ –≥–∏ –ø–æ–ª–∑–≤–∞—Ç–µ.


= slide '–ïvent emitter' do
  p –û—Ç –º–∏–Ω–∞–ª–∞—Ç–∞ –ª–µ–∫—Ü–∏—è –≤–∏–¥—è—Ö–º–µ –∫–∞–∫ –º–æ–∂–µ –¥–∞ —Å–∏ –Ω–∞–ø—Ä–∞–≤–∏–º –ø—Ä–æ—Å—Ç EventEmitter

= slide 'Async event emitter' do
  p –í —Å—ä—â–∏—è –¥—É—Ö —â–µ –Ω–∞–ø—Ä–∞–≤–∏–º –µ–¥–∏–Ω –∫–æ–π—Ç–æ –¥–∞ –≤–∏–∫–∞ —Å–ª—É—à–∞—Ç–µ–ª–∏—Ç–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ

  example:
    let mut emitter = AsyncEventEmitter::<&str, u32>::new();

    emitter.on("boot", |p| println!("{}", p));
    emitter.on("woot", |p| println!("{}", p));

    emitter.emit("boot", 1).unwrap();
    emitter.emit("woot", 2).unwrap();
    emitter.emit("boot", 3).unwrap();

= slide 'Async event emitter' do
  p –ù–µ–∫–∞ –¥–∞ –ø—Ä–æ–±–≤–∞–º–µ –Ω–∞–π-–±–∞–∑–æ–≤–æ—Ç–æ –Ω–µ—â–æ:

  example:
    use std::thread;

    fn emit<B>(&self, event: B, payload: P) -> bool where B: Borrow<E> {
        let event = event.borrow();

        match self.map.get(event) {
            Some(listeners) => {
                thread::spawn(|| {
                    listeners.iter().for_each(|f| (f.closure)(payload.clone()));
                });
                true
            },
            None => false
        }
    }

= slide 'Async event emitter' do
  pre
    ' error[E0277]: the trait bound `P: std::marker::Sync` is not satisfied
        --> src\main.rs:166:17
          |
      166 |     thread::spawn(|| {
          |     ^^^^^^^^^^^^^ `P` cannot be shared between threads safely
          |

      error[E0277]: the trait bound `std::ops::Fn(P) + 'static: std::marker::Sync` is not satisfied
        --> src\main.rs:166:17
          |
      166 |     thread::spawn(|| {
          |     ^^^^^^^^^^^^^ `std::ops::Fn(P) + 'static` cannot be shared between threads safely
          |

= slide 'Async event emitter' do
  p –ê –∫–∞–∫–≤–æ, –∞–∫–æ –ø–æ—Å–ª—É—à–∞–º–µ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞?

  list:
    `Fn(P) + 'static` -> `Fn(P) + Sync + 'static`
    `P: Clone` -> `P: Clone + Sync`

= slide 'Async event emitter' do
  pre
    ' error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
        --> src\main.rs:164:24
          |
      164 |         match self.map.get(event) {
          |                        ^^^
          |
      note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 159:5...
        --> src\main.rs:159:5
          |
      159 | /     fn emit&lt;B&gt;(&self, event: B, payload: P) -> bool where B: Borrow<E> {
      160 | |         use std::thread;
      161 | |
      162 | |         let event = event.borrow();
      ...   |
      172 | |         }
      173 | |     }
          | |_____^
      note: ...so that reference does not outlive borrowed content
        --> src\main.rs:164:15
          |
      164 |         match self.map.get(event) {
          |               ^^^^^^^^
          = note: but, the lifetime must be valid for the static lifetime...
      note: ...so that the type `[closure@src\main.rs:166:31: 168:18 listeners:&&std::vec::Vec<Listener<P>>, payload:&P]` will meet its required lifetime bounds
        --> src\main.rs:166:17
          |
      166 |                 thread::spawn(|| {
          |                 ^^^^^^^^^^^^^
= slide 'Async event emitter' do
  p –ú–∞–π —â–µ —Å–∏ –ø–æ–∫–æ–ø–∞–º–µ..

= slide 'Async event emitter' do
  p –ú–æ–∂–µ –±–∏ –¥–∞ –ø—Ä–æ–±–≤–∞–º–µ —Å <code>Arc</code> –∏ <code>Mutex</code>

  example:
    use std::sync::{Arc, Mutex};

    struct EventEmitter<E, P> where E: Eq + Hash, P: Clone {
        next_id: Id,
        map: HashMap<E, Arc<Mutex<Vec<Listener<P>>>>>
    }

= slide 'Async event emitter' do
  p –¢–æ–≥–∞–≤–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –º–∏–Ω–µ–º –∏ –∑–∞–º–µ—Å—Ç–∏–º listeners –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ —Å —Ç–æ–≤–∞

  example:
    let listeners = arc.lock().expect("Something went wrong")

= slide 'Async event emitter' do
  p –ó–∞ <code>on</code> –∏ </code>off</code> –µ —Ç—Ä–∏–≤–∏–∞–ª–Ω–æ, –∞–º–∏ <code>emit</code>?

  example:
    fn emit<B>(&self, event: B, payload: P) -> bool where B: Borrow<E> {
        let event = event.borrow();

        match self.map.get(event) {
            Some(arc) => {
                thread::spawn(|| {
                    let listeners = arc.lock().expect("Something went wrong");
                    listeners.iter().for_each(|f| (f.closure)(payload.clone()));
                });
                true
            },
            None => false
        }
    }

= slide 'Async event emitter' do
  p –ú–∞–π –∏–º–∞–º–µ –Ω–∞–ø—Ä–µ–¥—ä–∫?

  pre
    ' error[E0277]: the trait bound `P: std::marker::Send` is not satisfied in
      `[closure@src\main.rs:178:31: 181:18 arc:&std::sync::Arc<std::sync::Mutex<std::vec::Vec<Listener<P>>>>, payload:P]`
        --> src\main.rs:178:17
          |
      178 |     thread::spawn(|| {
          |     ^^^^^^^^^^^^^ `P` cannot be sent between threads safely
          |
          required by `std::thread::spawn`

      error[E0277]: the trait bound `std::ops::Fn(P) + 'static: std::marker::Send` is not satisfied
        --> src\main.rs:178:17
          |
      178 |     thread::spawn(|| {
          |     ^^^^^^^^^^^^^ `std::ops::Fn(P) + 'static` cannot be sent between threads safely
          |
          required by `Arc`

= slide 'Async event emitter' do
  p –ù–µ–∫–∞ –ø—Ä–æ–±–≤–∞–º–µ –ø–∞–∫, –Ω–æ —Ç–æ–∑–∏ –ø—ä—Ç –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ –∏—Å–∫–∞ <code>Send</code>

  list:
    `Fn(P) + 'static` -> `Fn(P) + Send + 'static`
    `P: Clone` -> `P: Clone + Send`

= slide 'Async event emitter' do
  p –û—Ñ—Ñ –ø–∞–∫ —Ç–æ–≤–∞..

  pre
    ' error[E0277]: the trait bound `P: std::marker::Sync` is not satisfied
        --> src\main.rs:178:17
          |
      178 |     thread::spawn(|| {
          |     ^^^^^^^^^^^^^ `P` cannot be shared between threads safely
          |

= slide 'Async event emitter' do
  p closure-–∞ —Å–µ –æ–ø–∏—Ç–≤–∞ –¥–∞ –ø—Ä–∏—Ö–≤–∞–Ω–µ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ –ø–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è

  example:
    thread::spawn(|| {
        /* ... */
    });

= slide 'Async event emitter' do
  p –ù–∞ –Ω–∞—Å –Ω–µ –Ω–∏ —Ç—Ä—è–±–≤–∞ —Ç–æ–≤–∞, <code>move</code> –µ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ –¥–æ–±—Ä–µ

  example:
    fn emit<B>(&self, event: B, payload: P) -> bool where B: Borrow<E> {
        let event = event.borrow();

        match self.map.get(event) {
            Some(arc) => {
                thread::spawn(move || {
                    let listeners = arc.lock().expect("Something went wrong");
                    listeners.iter().for_each(|f| (f.closure)(payload.clone()));
                });
                true
            },
            None => false
        }
    }

= slide 'Async event emitter' do
  pre
    ' error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
        --> src\main.rs:176:24
          |
      176 |         match self.map.get(event) {
          |                        ^^^
          |
      note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 165:5...
        --> src\main.rs:165:5
          |
      165 | /     fn emit&lt;B&gt;(&self, event: B, payload: P) -> bool where B: Borrow<E> {
      166 | |         let event = event.borrow();
      ...   |
      185 | |         }
      186 | |     }
          | |_____^
      note: ...so that reference does not outlive borrowed content
        --> src\main.rs:176:15
          |
      176 |         match self.map.get(event) {
          |               ^^^^^^^^
          = note: but, the lifetime must be valid for the static lifetime...
      note: ...so that the type `[closure@src\main.rs:178:31: 181:18 arc:&std::sync::Arc<std::sync::Mutex<std::vec::Vec<Listener<P>>>>, payload:P]` will meet its required lifetime bounds
        --> src\main.rs:178:17
          |
      178 |                 thread::spawn(move || {
          |

= slide 'Async event emitter' do
  p
    ' –ò–∑–≥–ª–µ–∂–¥–∞ –∏–∑—Ä–æ–¥—Å–∫–æ, –Ω–æ –ø—Ä–æ—Å—Ç–æ –∏—Å–∫–∞ –¥–∞ –Ω–∏ –∫–∞–∂–µ, —á–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è—Ç–∞ –¥–µ—Ç–æ –Ω–∏ –¥–∞–≤–∞
      <code>map.get</code> –Ω–µ –º–æ–∂–µ –¥–∞ —è –ø—Ä–µ–º–µ—Å—Ç–∏ —Ç—ä–π –∫–∞—Ç–æ –≤–µ—Ä–æ—è—Ç–Ω–æ —â–µ –Ω–∞–¥–∂–∏–≤–µ–µ main –Ω–∏—à–∫–∞—Ç–∞.

= slide 'Async event emitter' do
  p –†–µ—à–µ–Ω–∏–µ—Ç–æ –µ –ø—Ä–æ—Å—Ç–æ –¥–∞ –∫–ª–æ–Ω–∏—Ä–∞–º–µ <code>Arc</code>

  example:
    match self.map.get(event) {
        Some(arc) => {
            let arc = arc.clone();
            thread::spawn(move || {
                let listeners = arc.lock().expect("Something went wrong");
                listeners.iter().for_each(|f| (f.closure)(payload.clone()));
            });
            true
        },
        None => false
    }

= slide 'Async event emitter' do
  p üëè

  pre
    ' Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
      Running `target\debug\async_event_emitter.exe`

= slide 'Async event emitter' do
  p –°—É–ø–µ—Ä, –Ω–µ–∫–∞ –≤–∏–¥–∏–º –∫–∞–∫ —â–µ –≥–æ –ø–æ–ª–∑–≤–∞–º–µ —Ç–æ–≤–∞

  example:
    fn main() {
        let mut emitter = AsyncEventEmitter::new();

        emitter.on("boot", |p: String| println!("{}", p));
        let id = emitter.on("boot", |_| println!("hi"));

        emitter.off(id);

        emitter.emit("boot", "woot".to_string());
    }

  pre
    ' woot

= slide 'Async event emitter' do
  p –ò–∑–≥–ª–µ–∂–¥–∞ –¥–æ–±—Ä–µ :)

= slide 'Async event emitter' do
  p –ò–ª–∏ –ø—ä–∫ –Ω–µ..

  example:
    fn main() {
        let mut emitter = AsyncEventEmitter::<&str, u32>::new();

        emitter.on("boot", |p| println!("{}", p));
        emitter.on("woot", |p| println!("{}", p));

        emitter.emit("boot", 1).unwrap();
        emitter.emit("woot", 2).unwrap();
        emitter.emit("boot", 3).unwrap();
    }

  pre
    ' 1

= slide 'Async event emitter' do
  p –ü–∞–∫?

  pre
    ' 1
      2

= slide 'Async event emitter' do
  p –ò–∑–≥–ª–µ–∂–¥–∞ –≥–ª–∞–≤–Ω–∞—Ç–∞ –Ω–∏ –Ω–∏—à–∫–∞ –ø—Ä–∏–∫–ª—é—á–≤–∞ —Ä–∞–Ω–æ

= slide 'Async event emitter' do
  p –ú–æ–∂–µ –¥–∞ –ø—Ä–µ–ø—Ä–∞–≤–∏–º <code>emit</code> –º–µ—Ç–æ–¥–∞ –¥–∞ –Ω–∏ –≤—Ä—ä—â–∞ <code>JoinHandle</code>

  example:
    fn emit<B>(&self, event: B, payload: P) -> Option<JoinHandle<()>> where B: Borrow<E> {
        let event = event.borrow();

        self.map.get(event).map(|arc| {
            let arc = arc.clone();
            thread::spawn(move || {
                let listeners = arc.lock().expect("Something went wrong");
                listeners.iter().for_each(|f| (f.closure)(payload.clone()));
            })
        })
    }

= slide 'Async event emitter' do
  p –¢–∞–∫–∞ –º–æ–∂–µ –¥–∞ –ø–æ—Å—Ç–∏–≥–Ω–µ–º –Ω–µ—â–æ –ø–æ–¥–æ–±–Ω–æ –Ω–∞

  example:
    fn main() {
        let mut emitter = AsyncEventEmitter::<&str, u32>::new();
        emitter.on("boot", |p| println!("{}", p));
        emitter.on("woot", |p| println!("{}", p));

        let mut handles = Vec::new();

        for _ in 0..2 {
            handles.push(emitter.emit("boot", 1).unwrap());
            handles.push(emitter.emit("woot", 2).unwrap());
            handles.push(emitter.emit("boot", 3).unwrap());
        }

        for handle in handles {
            handle.join().unwrap();
        }
    }

= slide 'Async event emitter' do
  pre
    ' 1
      3
      2
      1
      3
      2
