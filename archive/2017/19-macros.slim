= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  list:
    –†–∞–∑–º–∏—Å–ª–∏ –≤—ä—Ä—Ö—É –¥–æ–º–∞—à–Ω–æ 3
    –ü—Ä–µ–≤—Ä—ä—â–∞–Ω–µ –Ω–∞ –¥–æ–º–∞—à–Ω–æ 3 –≤ "–∏—Å—Ç–∏–Ω—Å–∫–æ –Ω–µ—â–æ"
    –ß–µ—Ç–µ–Ω–µ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è, –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ —Ñ–ª–∞–≥–æ–≤–µ

= slide '–ú–∞–∫—Ä–æ—Å–∏' do
  img src="images/macros_are_cool.png"

= slide '–ú–∞–∫—Ä–æ—Å–∏' do
  list:
    –ü—ä—Ä–≤–æ: –ü—Ä–æ—Å—Ç–∏ –º–∞–∫—Ä–æ—Å–∏, the basics, –ª–µ—Å–Ω–∞ —Ä–∞–±–æ—Ç–∞, –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ø–æ–ª–µ–∑–Ω–∏ –Ω–µ—â–∞
    –ü–æ—Å–ª–µ: –ö–∞–∫ *–≤—Å—ä—â–Ω–æ—Å—Ç* —Ä–∞–±–æ—Ç—è—Ç –Ω–µ—â–∞—Ç–∞. Edge cases. –°–ª–æ–∂–Ω–æ—Å—Ç. –ù–µ–ø—Ä–∏—è—Ç–Ω–æ—Å—Ç.

= slide 'try!' do
  p –¢–æ–≤–∞ –≤–µ—á–µ —Å–º–µ –≥–æ –≤–∏–∂–¥–∞–ª–∏

  example:
    macro_rules! try {
        ($expr:expr) => {
            match $expr {
                Ok(value) => value,
                Err(e) => return Err(e.into()),
            }
        }
    }

= slide 'add!' do
  p –û–±—â–∞—Ç–∞ —Å—Ö–µ–º–∞

  example:
    macro_rules! add {
        ($var1:expr, $var2:expr) => {
            $var1 + $var2;
        }
    }

    fn main() {
        println!("{}", add!(1, 1));
        println!("{}", add!("foo".to_string(), "bar"));
    }

= slide 'add!' do
  p –û–±—â–∞—Ç–∞ —Å—Ö–µ–º–∞

  list:
    `macro_rules!` –≤—Å—ä—â–Ω–æ—Å—Ç –Ω–µ –µ –º–∞–∫—Ä–æ, –∞ –µ "syntax extension", –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω–æ –Ω–∞ –Ω–∏–≤–æ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä
    –ò–º–µ—Ç–æ –Ω–∞ –º–∞–∫—Ä–æ—Å–∞ —Å–ª–µ–¥–≤–∞, –ø–æ—Å–ª–µ–¥–≤–∞–Ω–æ –æ—Ç –Ω—è–∫–∞–∫–≤–∏ —Å–∫–æ–±–∫–∏ (–∫–∞–∫–≤–∏—Ç–æ –∏ –¥–∞ –µ)
    –ê—Ä–≥—É–º–µ–Ω—Ç–∏, –ø–æ—Å–ª–µ–¥–≤–∞–Ω–∏ –æ—Ç —Å—Ç—Ä–µ–ª–∫–∏—á–∫–∞ –∏ –æ—â–µ –µ–¥–∏–Ω —á–∏—Ñ—Ç —Å–∫–æ–±–∏: `(...) => { ... }`
    "–ü—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ" (–Ω–µ —Å–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏) `$var1`, `$var2` —Å–∞ –æ—Ç "—Ç–∏–ø" expression -- —Ü—è–ª–æ—Å—Ç–µ–Ω –∏–∑—Ä–∞–∑

= slide 'add!' do
  p –ó–∞—â–æ –Ω–µ "–ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏"? –ó–∞—â–æ—Ç–æ –≤ –∫—Ä—ä–≥–ª–∏—Ç–µ —Å–∫–æ–±–∏ —Å–µ –ø—Ä–∞–≤–∏ pattern-matching –Ω–∞ –Ω–∏–≤–æ tokens:

  example:
    macro_rules! add {
        (–ß—à, —è —Å—ä–±–µ—Ä–∏ ($var1:expr) –∏ ($var2:expr)) => {
            $var1 + $var2;
        }
    }

    fn main() {
        println!("{}", add!(–ß—à, —è —Å—ä–±–µ—Ä–∏ (1) –∏ (1)));
        println!("{}", add!(–ß—à, —è —Å—ä–±–µ—Ä–∏ ("foo".to_string()) –∏ ("bar")));
    }

= slide 'add!' do
  p –ó–∞—â–æ –∏–º–∞ —Å–∫–æ–±–∏? –ó–∞ –¥–∞ —Å–µ –∑–Ω–∞–µ –∫—ä–¥–µ —Å–≤—ä—Ä—à–≤–∞ expression/–∏–∑—Ä–∞–∑.

  example:
    macro_rules! add {
        (–ß—à, —è —Å—ä–±–µ—Ä–∏ $var1:expr –∏ $var2:expr) => {
            $var1 + $var2;
        }
    }

  ' <pre>
    error: `$var1:expr` is followed by `–∏`, which is not allowed for `expr` fragments
    --> src/main.rs:2:30
      |
    2 |     (–ß—à, —è —Å—ä–±–µ—Ä–∏ $var1:expr –∏ $var2:expr) => {
      |                              ^
    </pre>

= slide 'add!' do
  p –ó–∞ <code>expr</code> —Å–∞ –ø–æ–∑–≤–æ–ª–µ–Ω–∏ —Å–∞–º–æ <code>,</code>, <code>;</code> –∏ <code>=&gt;</code>, –∞–∫–æ –Ω–µ —Å–∞ –≤ —Å–∫–æ–±–∏

  example:
    macro_rules! add {
        (–ß—à, —è —Å—ä–±–µ—Ä–∏ $var1:expr, $var2:expr) => {
            $var1 + $var2;
        }
    }

    fn main() {
        println!("{}", add!(–ß—à, —è —Å—ä–±–µ—Ä–∏ 1, 1));
        println!("{}", add!(–ß—à, —è —Å—ä–±–µ—Ä–∏ "foo".to_string(), "bar"));
    }

= slide 'map!' do
  p –ù–µ—â–æ –º–∞–ª–∫–æ –ø–æ-–ø—Ä–∞–∫—Ç–∏—á–Ω–æ

  example:
    macro_rules! map {
      {
        $( $key: expr : $value: expr ),*
      } => {
        // –ó–∞–±–µ–ª–µ–∂–µ—Ç–µ –±–ª–æ–∫–∞
        {
          let mut map = ::std::collections::HashMap::new();
          $( map.insert($key, $value); )*
          map
        }
      }
    }

= slide 'map!' do
  p –ö–∞–∫–≤–æ –ø—Ä–∞–≤–∏ <code>$( ... ),*</code>?

  list:
    –¢–æ–≤–∞ –µ repetition operator
    –í–∏–Ω–∞–≥–∏ —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç `$( ... )` –∏ –µ–¥–Ω–æ –æ—Ç –¥–≤–µ—Ç–µ:
    `*` - 0 –∏–ª–∏ –ø–æ–≤–µ—á–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
    `+` - 1 –∏–ª–∏ –ø–æ–≤–µ—á–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
    –ú–æ–∂–µ –¥–∞ —Å–ª–æ–∂–∏–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª –≤–µ–¥–Ω–∞–≥–∞ —Å–ª–µ–¥ –∑–∞—Ç–≤–∞—Ä—è—â–∞—Ç–∞ —Å–∫–æ–±–∞ –Ω–∞–ø—Ä–∏–º–µ—Ä `,`
    `$( ... ),*` —Ç—ä—Ä—Å–∏ –Ω–µ—â–æ –æ—Ç –≤–∏–¥–∞ `... , ... , ...`
    –û–ø–µ—Ä–∞—Ç–æ—Ä–∞ –Ω–µ –ø–æ–¥–¥—ä—Ä–∂–∞ optional trailing —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª

= slide 'map!' do
  p –û–∫, –Ω–µ–∫–∞ –¥–∞ –∫–æ–º–ø–∏–ª–∏—Ä–∞–º–µ

= slide 'map!' do
  ' <pre>
    error: `$key:expr` is followed by `:`, which is not allowed for `expr` fragments
    --> src/main.rs:4:23
      |
    4 |         $( $key: expr : $value: expr ),*
      |                       ^
    </pre>

= slide 'map!' do
  p –ü—Ä–∞–≤–∏–ª–∞—Ç–∞ —Å–∞ —Å–∏ –ø—Ä–∞–≤–∏–ª–∞.. –©–µ –≥–∏ —Ä–∞–∑–≥–ª–µ–¥–∞–º–µ –ø–æ–¥—Ä–æ–±–Ω–æ –ø–æ-–∫—ä—Å–Ω–æ

  example:
    macro_rules! map {
      {
        $( $key: expr => $value: expr ),*
      } => {
        {
          let mut map = ::std::collections::HashMap::new();
          $( map.insert($key, $value); )*
          map
        }
      }
    }

= slide 'map!' do
  example:
    let m = map! {
        "a" => 1,
        "b" => 2
    };

    println!("{:?}", m);

  p –ò–∑—Ö–æ–¥:

  ' <pre>
    {"b": 2, "a": 1}
    </pre>

= slide 'map!' do
  p –ê –∫–∞–∫–≤–æ —Å—Ç–∞–≤–∞, –∞–∫–æ –∏—Å–∫–∞–º–µ –¥–∞ –ø–æ–¥–¥—ä—Ä–∂–∞–º–µ trailing comma ü§î

  example:
    let m = map! {
        "a" => 1,
        "b" => 2,
    };

    println!("{:?}", m);

= slide 'map!' do
  ' <pre>
    error: unexpected end of macro invocation
    --> src/main.rs:4:17
      |
    4 |         "b" => 2,
      |                 ^
    </pre>

= slide 'map!' do
  p –ù–µ —Ç–æ—á–Ω–æ –∫–∞–∫–≤–æ—Ç–æ –æ—á–∞–∫–≤–∞—Ö–º–µ..

= slide 'map!' do
  p –ú–æ–∂–µ –±–∏ —Ç–∞–∫–∞?

  example:
    macro_rules! map {
      {
        $( $key: expr => $value: expr ),*,
      } => {
        /* ... */
      }
    }

= slide 'map!' do
  example:
    let m = map! {
        "a" => 1,
        "b" => 2
    };

  ' <pre>
    error: unexpected end of macro invocation
    --> src/main.rs:4:16
      |
    4 |         "b" => 2
      |                ^
    </pre>

= slide 'map!' do
  p –ù–µ..

= slide 'map!' do
  p –ù–µ –±–æ–π—Ç–µ —Å–µ, –∏–º–∞ —Å–∏ —Ç—Ä–∏–∫ –∑–∞ —Ç–æ–≤–∞

  example:
    macro_rules! map {
      {
        $( $key: expr => $value: expr ),* $(,)*
      } => {
        /* ... */
      }
    }

= slide 'map!' do
  p –ù–µ–¥–æ—Å—Ç–∞—Ç—ä–∫–∞ –µ, —á–µ –º–æ–∂–µ –¥–∞ match-–Ω–µ–º –Ω–µ—â–æ —Ç–∞–∫–æ–≤–∞. –©–µ –ø–æ–∫–∞–∂–µ–º –ø–æ-–∫—ä—Å–Ω–æ –∏ –¥—Ä—É–≥ –Ω–∞—á–∏–Ω

  example:
    let m = map! {
        "a" => 1,
        "b" => 2,,,,,,,,,,,,
    };

= slide 'map!' do
  p Guess macro_rules! ¬Ø\_(„ÉÑ)_/¬Ø

= slide 'macros 2.0' do
  p –í –º–æ–º–µ–Ω—Ç–∞ –º–∞–∫—Ä–æ—Å–∏—Ç–µ —Å–∞ –≤ –ø—Ä–æ—Ü–µ—Å –Ω–∞ –ø—Ä–µ—Ä–∞–±–æ—Ç–∫–∞ –∫—ä–º macros 2.0, –∫—ä–¥–µ—Ç–æ —â–µ –∏–º–∞ <code>?</code>

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p –ú–∞–∫—Ä–æ—Å–∏—Ç–µ –≤ Rust —Å–∞ —Ö–∏–≥–∏–µ–Ω–∏—á–Ω–∏

  example:
    macro_rules! five_times {
        ($x:expr) => (5 * $x);
    }

    assert_eq!(25, five_times!(2 + 3));

  p –ù–µ—â–æ –ø–æ–¥–æ–±–Ω–æ –≤ C/C++ –±–∏ –∏–∑—á–∏—Å–ª–æ <code>13</code>

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p –í —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä –æ—Ç–Ω–æ–≤–æ –∑–∞—Ä–∞–¥–∏ —Ö–∏–≥–∏–µ–Ω–∞ –¥–≤–∞—Ç–∞ state-–∞ –Ω–µ —Å–µ shadow-–≤–∞—Ç –≤–∑–∞–∏–º–Ω–æ

  example:
    macro_rules! log {
        ($msg:expr) => {{
            let state: i32 = get_log_state();
            if state > 0 {
                println!("log({}): {}", state, $msg);
            }
        }};
    }

    let state: &str = "reticulating splines";
    log!(state);

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p
    ' –í—Å—è–∫–æ —Ä–∞–∑–≥—ä–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Ä–æ—Å —Å–µ —Å–ª—É—á–≤–∞ –≤ —Ä–∞–∑–ª–∏—á–µ–Ω —Å–∏–Ω—Ç–∞–∫—Ç–∏—á–µ–Ω –∫–æ–Ω—Ç–µ–∫—Å—Ç. –í —Ç–æ–∑–∏ —Å–ª—É—á–∞–π –º–æ–∂–µ –¥–∞ –≥–æ
      –º–∏—Å–ª–∏—Ç–µ –≤—Å–µ –µ–¥–Ω–æ –¥–≤–µ—Ç–µ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –∏–º–∞—Ç —Ä–∞–∑–ª–∏—á–µ–Ω —Ü–≤—è—Ç –∫–æ–π—Ç–æ –≥–∏ —Ä–∞–∑–≥—Ä–∞–Ω–∏—á–∞–≤–∞.

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p –ü–æ —Ç–∞–∑–∏ –ø—Ä–∏—á–∏–Ω–∞ –Ω–µ –º–æ–∂–µ –¥–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–º–µ –Ω–æ–≤–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ —á—Ä–µ–∑ –º–∞–∫—Ä–æ—Å –ø–æ —Å–ª–µ–¥–Ω–∏—è –Ω–∞—á–∏–Ω

  example:
    macro_rules! foo {
        () => (let x = 3;);
    }

    foo!();
    println!("{}", x); // –∫–æ–º–ø–∏–ª–∞—Ü–∏–æ–Ω–Ω–∞ –≥—Ä–µ—à–∫–∞

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p –©–µ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø–æ–¥–∞–¥–µ–º –∏–º–µ—Ç–æ –Ω–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ –Ω–∞ –º–∞–∫—Ä–æ—Å–∞ –∑–∞ –¥–∞ —Å–µ –ø–æ–ª—É—á–∏

  example:
    macro_rules! foo {
        ($v:ident) => (let $v = 3;);
    }

    foo!(x);
    println!("{}", x);

= slide '–•–∏–≥–∏–µ–Ω–∞' do
  p
    ' –ü—Ä–∞–≤–∏–ª–æ –≤–∞–∂–∏ –∑–∞ <code>let</code> –∏ —Ü–∏–∫–ª–∏ –∫–∞—Ç–æ <code>loop while for</code>,
      –Ω–æ –Ω–µ –∏ –∑–∞ <code>items</code>, –∫–æ–µ—Ç–æ –∑–Ω–∞—á–∏, —á–µ —Å–ª–µ–¥–Ω–æ—Ç–æ —â–µ —Å–µ –∫–æ–º–ø–∏–ª–∏—Ä–∞

  example:
    macro_rules! foo {
        () => (fn x() { });
    }

    foo!();
    x();

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å', '–ò–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ –º–∞–∫—Ä–æ—Å–∏' do
  p –ú–∞–∫—Ä–æ—Å–∏—Ç–µ —Å–ª–µ–¥–≤–∞—Ç —Å—ä—â–∏—Ç–µ –ø—Ä–∞–≤–∏–ª–∞ –∫–∞–∫—Ç–æ –æ—Å—Ç–∞–Ω–∞–ª–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –Ω–∞ Rust

  list:
    `foo!(...);`
    `foo![...];`
    `foo! { ... }`

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å' do
  list:
    –ú–∞–∫—Ä–æ—Å–∏—Ç–µ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å—ä–¥—ä—Ä–∂–∞—Ç —Å–∞–º–æ –≤–∞–ª–∏–¥–Ω–∏ Rust tokens
    –°–∫–æ–±–∏—Ç–µ –≤ –º–∞–∫—Ä–æ—Å–∏—Ç–µ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∞ –±–∞–ª–∞–Ω—Å–∏—Ä–∞–Ω–∏ —Ç.–µ `foo!([)` –µ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ
    –ë–µ–∑ —Ç–æ–≤–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ, Rust –Ω—è–º–∞ –∫–∞–∫–¥–∞ –∑–Ω–∞–µ –∫—ä–¥–µ —Å–≤—ä—Ä—à–≤–∞ –∏–∑–≤–∏–∫–≤–∞–Ω–µ—Ç–æ –Ω–∞ –º–∞–∫—Ä–æ—Å–∞

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å' do
  p –§–æ—Ä–º–∞–ª–Ω–æ –∏–∑–≤–∏–∫–≤–∞–Ω–µ—Ç–æ –Ω–∞ –º–∞–∫—Ä–æ—Å —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç –ø–æ—Ä–µ–¥–∏—Ü–∞ –æ—Ç <code>token trees</code> –∫–æ–∏—Ç–æ —Å–∞

  list:
    –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∞ –ø–æ—Ä–µ–¥–∏—Ü–∞ –æ—Ç token trees –æ–±–≥—Ä–∞–¥–µ–Ω–∞ –æ—Ç `()`, `[]` –∏–ª–∏ `{}`
    –≤—Å–µ–∫–∏ –¥—Ä—É–≥ –µ–¥–∏–Ω–∏—á–µ–Ω token

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å' do
  p
    ' –ó–∞—Ç–æ–≤–∞ Rust –º–∞–∫—Ä–æ—Å–∏—Ç–µ –≤–∏–Ω–∞–≥–∏ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∏—Ä–∞—Ç –∑–∞—Ç–≤–∞—Ä—è–Ω–µ—Ç–æ –Ω–∞ —Å–∫–æ–±–∏—Ç–µ –ø—Ä–µ–¥ match-–≤–∞–Ω–µ—Ç–æ,
      –∫–æ–µ—Ç–æ –µ –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ –Ω—è–∫–æ–∏ –ø–æ–¥—Ö–æ–¥–∏ –∑–∞ match-–≤–∞–Ω–µ

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å', 'Metavariables & Fragment specifiers' do
  p T–∏–ø–æ–≤–µ—Ç–µ –Ω–∞ –º–µ—Ç–∞–ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏—Ç–µ —Å–∞

  list:
    `ident`: an identifier. `x`; `foo`
    `path`: a qualified name. `T::SpecialA`
    `expr`: an expression. `2 + 2`; `if true { 1 } else { 2 }`; `f(42)`
    `ty`: a type. `i32`; `Vec<(char, String)>`; `&T`
    `pat`: a pattern. `Some(t)`; `(17, 'a')`; `_`
    `stmt`: a single statement. `let x = 3`
    `block`: a brace-delimited sequence of statements and optionally an expression. `{ log(error, "hi"); return 12; }`
    `item`: an item. `fn foo() { }`; `struct Bar;`
    `meta`: a "meta item", as found in attributes. `cfg(target_os = "windows")`
    `tt`: a single token tree.

= slide '–°–∏–Ω—Ç–∞–∫—Å–∏—Å', 'Metavariables & Fragment specifiers' do
  p –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ç–∞ –∑–∞ —Ç–∏–ø–æ–≤–µ—Ç–µ —Å–∞

  list:
    `expr` and `stmt` variables may only be followed by one of: `=> , ;`
    `ty` and `path` variables may only be followed by one of: `=> , = | ; : > [ { as where`
    `pat` variables may only be followed by one of: `=> , = | if in`
    Other variables may be followed by any token.

= slide '–†—ä–∫–∞–≤–∏' do
  p –ú–∞–∫—Ä–æ—Å–∏—Ç–µ –º–æ–≥–∞—Ç –¥–∞ –∏–º–∞—Ç –ø–æ–≤–µ—á–µ –æ—Ç –µ–¥–∏–Ω —Ä—ä–∫–∞–≤ –∑–∞ matching —Ä–∞–∑–¥–µ–ª–µ–Ω–∏ —Å <code>;</code>

  example:
    macro_rules! my_macro {
        ($e: expr) => (...);
        ($i: ident) => (...);
        (for $i: ident in $e: expr) => (...);
    }

= slide '–†—ä–∫–∞–≤–∏' do
  p –ò–º–∞ –∏ –∫–æ–Ω–≤–µ–Ω—Ü–∏—è –∑–∞ private —Ä—ä–∫–∞–≤–∏ <code>@text</code>, –∫–æ–∏—Ç–æ –¥–∞ —Å–µ –≤–∏–∫–∞—Ç —á—Ä–µ–∑ —Ä–µ–∫—É—Ä—Å–∏—è

  example:
    macro_rules! my_macro {
        (for $i: ident in $e: expr) => (...);
        (@private1 $e: expr) => (...);
        (@private2 $i: ident) => (...);
    }

= slide '–†–µ–∫—É—Ä—Å–∏—è' do
  p –ú–∞–∫—Ä–æ—Å–∏—Ç–µ –º–æ–≥–∞—Ç –¥–∞ –∏–∑–≤–∏–∫–≤–∞—Ç –¥—Ä—É–≥–∏ –º–∞–∫—Ä–æ—Å–∏ –∏ –¥–æ—Ä–∏ —Å–µ–±–µ —Å–∏ –∫–∞–∫—Ç–æ —Ç–æ–∑–∏ –ø—Ä–æ—Å—Ç html shorthand

  example:
    macro_rules! write_html {
        ($w: expr, ) => (());

        ($w: expr, $e: tt) => (write!($w, "{}", $e));

        ($w: expr, $tag: ident [ $( $inner: tt )* ] $( $rest: tt )*) => {{
            write!($w, "<{}>", stringify!($tag));
            write_html!($w, $($inner)*);
            write!($w, "</{}>", stringify!($tag));
            write_html!($w, $($rest)*);
        }};
    }

= slide '–†–µ–∫—É—Ä—Å–∏—è' do
  example:
    fn main() {
        use std::fmt::Write;
        let mut out = String::new();

        write_html! {
            &mut out,
            html[
                head[title["Macros guide"]]
                body[h1["Macros are the best!"]]
            ]
        }

        assert_eq!(out,
            "<html><head><title>Macros guide</title></head>\
            <body><h1>Macros are the best!</h1></body></html>");
    }

= slide '–†–µ–∫—É—Ä—Å–∏—è' do
  p –ù–µ–∫–∞ –Ω–∞–ø—Ä–∞–≤–∏–º –æ–Ω–∑–∏ —Ö–∞–∫ –∑–∞ trailing comma –ø–æ-–º–∞–ª–∫–æ —Ö–∞–∫ —Å —Ç–µ–∑–∏ –ø–æ–∑–Ω–∞–Ω–∏—è

  example:
    macro_rules! map {
      { $( $key: expr => $value: expr ),*, } => {
        map!( $( $key => $value ),* );
      };

      { $( $key: expr => $value: expr ),* } => {
        {
          let mut map = ::std::collections::HashMap::new();
          $( map.insert($key, $value); )*
          map
        }
      };
    }

= slide 'Scoping' do
  p –ö–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ —Ä–∞–∑–≥—ä–≤–∞ –º–∞–∫—Ä–æ—Å–∏—Ç–µ –≤ —Ä–∞–Ω–Ω–∞ —Ñ–∞–∑–∞ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ü–∏—è, –∑–∞—Ç–æ–≤–∞ –∏–º–∞—Ç —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞ –≤–∏–¥–∏–º–æ—Å—Ç

  list:
    –î–µ—Ñ–∏–Ω–∏—Ü–∏–∏—Ç–µ –∏ —Ä–∞–∑–≥—Ä—ä—â–∞–Ω–∏—è—Ç–∞ —Å–µ —Å–ª—É—á–≤–∞—Ç –≤ –µ–¥–Ω–æ depth-first lexical-order –æ–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ crate-a
    –ó–∞—Ç–æ–≤–∞ –≤–∏–¥–∏–º–æ—Å—Ç—Ç–∞ –Ω–∞ –º–∞–∫—Ä–æ—Å –µ *—Å–ª–µ–¥* –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è—Ç–∞ –º—É - –≤ —Å—ä—â–∏—è scope –∏ –≤ child mods
    –ò–∑–ø–æ–ª–∑–≤–∞–Ω–µ—Ç–æ –Ω–∞ –º–∞–∫—Ä–æ—Å –æ—Ç –¥—Ä—É–≥ –º–æ–¥—É–ª —Å—Ç–∞–≤–∞ —á—Ä–µ–∑ `#[macro_use]` –ø—Ä–µ–¥–∏ –º—è—Å—Ç–æ—Ç–æ, –∫—ä–¥–µ—Ç–æ –≥–æ –ø–æ–ª–∑–≤–∞—Ç–µ

= slide 'Scoping' do
  p –ò–º–∞–º–µ –º–∞–∫—Ä–æ—Å–∏ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –≤ <code>macros</code> –∏ —â–µ –≥–∏ –ø–æ–∑–ª–≤–∞–º–µ –≤ <code>client</code>

  div style="display: flex; flex-direction: row; justify-content: center"
    div style="width: 100%; padding: 10px; border-right: 1px solid gray;"
      example:
        #[macro_use]
        mod macros;
        mod client; // –æ–∫

    div style="width: 100%; padding: 10px 10px 10px 40px;"
      example:
        mod client; // –∫–æ–º–ø–∏–ª–∞—Ü–∏–æ–Ω–Ω–∞ –≥—Ä–µ—à–∫–∞
        #[macro_use]
        mod macros;

= slide 'Scoping' do
  p –ú–∞–∫—Ä–æ—Å–∏ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω–∏ –≤ –±–ª–æ–∫–æ–≤–µ, —Ñ—É–Ω–∫—Ü–∏–∏ –∏–ª–∏ –¥—Ä—É–≥–∏ –ø–æ–¥–æ–±–Ω–∏ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —Å–∞ –≤–∏–¥–∏–º–∏ —Å–∞–º–æ —Ç–∞–º

  example:
    fn main() {
        macro_rules! map { ... }
    }

= slide 'Scoping' do
  p –ü—Ä–∏ —Ä–∞–±–æ—Ç–∞ –Ω–∞ –Ω–∏–≤–æ crate

  list:
    —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ `#[macro_use]` –∑–∞ –∏–º–ø–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–æ –∏–ª–∏ `#[macro_use(my_macro, other_macro)]`
    –∑–∞ –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏—Ç–µ –º–∞–∫—Ä–æ—Å–∏—Ç–µ –¥–æ—Å—Ç—ä–ø–Ω–∏ –∑–∞ –¥—Ä—É–≥–∏ crate-–æ–≤–µ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ `#[macro_export]`
    –∏–º–∞ –∏ [–¥—Ä—É–≥–∏ –∞—Ç—Ä–∏–±—É—Ç–∏](https://doc.rust-lang.org/stable/reference/attributes.html#macro-related-attributes)

= slide 'Debugging' do
  p –î–µ–±—ä–≥–≤–∞–Ω–µ—Ç–æ –Ω–∞ –º–∞–∫—Ä–æ—Å–∏ –µ —Å–ª–æ–∂–Ω–æ, –Ω–æ –∏–º–∞ –Ω—è–∫–æ–∏ –ø–æ–ª–µ–∑–Ω–∏ –∫–æ–º–∞–Ω–¥–∏

  list:
    `rustc --pretty expanded`
    `--pretty expanded,hygiene` –∑–∞ –¥–∞ —Å–µ –∑–∞–ø–∞–∑—è—Ç syntax scope-–æ–≤–µ—Ç–µ
    `cargo +nightly rustc -- -Z unstable-options --pretty=expanded`

= slide 'Debugging' do
  p –ò–º–∞ –∏ —É–¥–æ–±–Ω–∏, –Ω–æ –Ω–µ—Å—Ç–∞–±–∏–ª–Ω–∏ –º–∞–∫—Ä–æ—Å–∏, –∫–æ–∏—Ç–æ —Å–µ –ø–æ–ª–∑–≤–∞—Ç –ø—Ä–µ–∑ feature gate –Ω–∞ nightly

  list:
    `log_syntax!(...)` - –ø—Ä–∏–Ω—Ç–∏—Ä–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ —Å–∏ –ø—Ä–∏ –∫–æ–º–ø–∏–ª–∞—Ü–∏—è –Ω–∞ stdout –∏ —Å–µ —Ä–∞–∑–≥—Ä—ä—â–∞ –¥–æ –Ω–∏—â–æ
    `trace_macros!(true)` - –≤–∫–ª—é—á–≤–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–Ω–∏ —Å—ä–æ–±—â–µ–Ω–∏—è –ø—Ä–∏ —Ä–∞–∑–≥—Ä—ä—â–∞–Ω–µ –Ω–∞ –º–∞–∫—Ä–æ—Å
    `trace_macros!(false)` - –∏–∑–∫–ª—é—á–≤–∞ —Å—ä–æ–±—â–µ–Ω–∏—è—Ç–∞

= slide '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ –º–∞–∫—Ä–æ—Å–∏' do
  list:
    `panic!` - –ø–∞–Ω–∏—Ä–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞
    `vec!` - —Å—ä–∑–¥–∞–≤–∞ –≤–µ–∫—Ç–æ—Ä –æ—Ç –µ–ª–µ–º–µ–Ω—Ç–∏
    `assert!` & `assert_eq!` - –∏–∑–ø–æ–ª–∑–≤–∞—Ç —Å–µ –ø—Ä–∏ —Ç–µ—Å—Ç–æ–≤–µ –∑–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–∞–Ω–Ω–∏—Ç–µ
    https://doc.rust-lang.org/stable/std/#macros

= slide 'Advanced', 'TT Muncher' do
  example:
    macro_rules! write_html {
        ($w: expr, ) => (());

        ($w: expr, $e: tt) => (write!($w, "{}", $e));

        ($w: expr, $tag: ident [ $( $inner: tt )* ] $( $rest: tt )*) => {{
            write!($w, "<{}>", stringify!($tag));
            write_html!($w, $($inner)*);
            write!($w, "</{}>", stringify!($tag));
            write_html!($w, $($rest)*);
        }};
    }

= slide 'Advanced', 'TT Muncher' do
  example:
    write_html! {
        &mut out,
        html[
            head[title["Macros guide"]]
            body[h1["Macros are the best!"]]
        ]
    }

= slide 'Advanced', 'Push-Down Accumulation' do
  p –ú–∞–∫—Ä–æ—Å, –∫–æ–π—Ç–æ –∏–Ω–∏–∑–∏–∞–ª–∏–∑–∏—Ä–∞ –º–∞—Å–∏–≤ –¥–æ 3 –µ–ª–µ–º–µ–Ω—Ç–∞

  example:
    macro_rules! init_array {
        [$e:expr; $n:tt] => {{
            let e = $e;
            init_array!(@accum ($n, e.clone()) -> ())
        }};
        (@accum (3, $e:expr) -> ($($body:tt)*)) => { init_array!(@accum (2, $e) -> ($($body)* $e,)) };
        (@accum (2, $e:expr) -> ($($body:tt)*)) => { init_array!(@accum (1, $e) -> ($($body)* $e,)) };
        (@accum (1, $e:expr) -> ($($body:tt)*)) => { init_array!(@accum (0, $e) -> ($($body)* $e,)) };
        (@accum (0, $_e:expr) -> ($($body:tt)*)) => { init_array!(@as_expr [$($body)*]) };
        (@as_expr $e:expr) => { $e };
    }

    let strings: [String; 3] = init_array![String::from("hi!"); 3];

= slide 'Advanced', 'Push-Down Accumulation' do
  p –ê –Ω–µ –º–æ–∂–µ –ª–∏ –¥–∞ –æ–ø—Ä–æ—Å—Ç–∏–º –Ω–µ—â–∞—Ç–∞ –¥–æ —Ç–æ–≤–∞?

  example:
    macro_rules! init_array {
        (@accum 0, $_e:expr) => {/* empty */};
        (@accum 1, $e:expr) => {$e};
        (@accum 2, $e:expr) => {$e, init_array!(@accum 1, $e)};
        (@accum 3, $e:expr) => {$e, init_array!(@accum 2, $e)};
        [$e:expr; $n:tt] => {
            {
                let e = $e;
                [ init_array!(@accum $n, e) ]
            }
        };
    }

= slide 'Advanced', 'Push-Down Accumulation' do
  p –ù–µ, –∑–∞—â–æ—Ç–æ —Ç–æ–≤–∞ –±–∏ –¥–æ–≤–µ–ª–æ –¥–æ —Å–ª–µ–¥–Ω–æ—Ç–æ —Ä–∞–∑–≥—ä–≤–∞–Ω–µ

  example:
    init_array!(@accum 3, e)
    e, init_array!(@accum 2, e)
    e, e, init_array!(@accum 1, e)
    e, e, e
    [e, e, e]

  p –¢—É–∫ –≤—Å—è–∫–∞ –ø–æ–º–æ—â–Ω–∞ —Å—Ç—ä–ø–∫–∞ —â–µ –µ –Ω–µ–≤–∞–ª–∏–¥–µ–Ω Rust —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏ —Ç–æ–≤–∞ –Ω–µ –µ –ø–æ–∑–≤–æ–ª–µ–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Å—Ç—ä–ø–∫–∏—Ç–µ

= slide 'Advanced', 'Push-Down Accumulation' do
  p
    ' Push-Down –Ω–∏ –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ –ø—Ä–∞–≤–∏–º –ø–æ–¥–æ–±–Ω–∏ –∫–æ–Ω—Å—Ç—Ä–∏–∫—Ü–∏–∏ —á—Ä–µ–∑ –∞–∫—É–º—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Ç–æ–∫–µ–Ω–∏,
      –±–µ–∑ –¥–∞ —Å–µ –Ω–∞–ª–∞–≥–∞ –¥–∞ –∏–º–∞–º–µ –≤–∞–ª–∏–¥–µ–Ω —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –ø—Ä–µ–∑ —Ü—è–ª–æ—Ç–æ –≤—Ä–µ–º–µ.

= slide 'Advanced', 'Push-Down Accumulation' do
  p –†–∞–∑–≥—ä–≤–∫–∞ –Ω–∞ –ø—ä—Ä–≤–∏—è –ø—Ä–∏–º–µ—Ä –∏–∑–≥–ª–µ–∂–¥–∞ —Ç–∞–∫–∞

  example:
    init_array! { String:: from ( "hi!" ) ; 3 }
    init_array! { @ accum ( 3 , e . clone (  ) ) -> (  ) }
    init_array! { @ accum ( 2 , e.clone() ) -> ( e.clone() , ) }
    init_array! { @ accum ( 1 , e.clone() ) -> ( e.clone() , e.clone() , ) }
    init_array! { @ accum ( 0 , e.clone() ) -> ( e.clone() , e.clone() , e.clone() , ) }
    init_array! { @ as_expr [ e.clone() , e.clone() , e.clone() , ] }

= slide 'Advanced' do
  p Push-Down Accumulation —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞ –≤ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è —Å TT Muncher, –∑–∞ –¥–∞ —Å–µ –ø–∞—Ä—Å–≤–∞—Ç –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ —Å–ª–æ–∂–Ω–∏ –≥—Ä–∞–º–∞—Ç–∏–∫–∏

= slide '–ú–∞—Ç–µ—Ä–∏–∞–ª–∏' do
  list:
    [First edition book](https://doc.rust-lang.org/stable/book/first-edition/macros.html)
    [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/README.html)
