= slide '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∏ –Ω–µ—â–∞' do
  p –í—Ç–æ—Ä–æ –¥–æ–º–∞—à–Ω–æ! –°–∫–æ—Ä–æ!

= slide '–í—ä–ø—Ä–æ—Å' do
  p –ö–∞–∫–≤–∏ lifetimes —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –¥–æ–±–∞–≤—è—Ç, –∑–∞ –¥–∞ —Å–µ –∫–æ–º–ø–∏–ª–∏—Ä–∞?

  example:
    fn substring_starting_from(text: &str, query: &str) -> &str {
        match text.find(query) {
            Some(index) => &text[index..],
            None => "",
        }
    }

    fn main() {
        let result = substring_starting_from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000", "—Ü–≤—è—Ç");
        println!("{}", result);

        let text = String::from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000");
        let result = substring_starting_from(&text, &String::from("—Ü–≤—è—Ç"));
        println!("{}", result);
    }

= slide '–û—Ç–≥–æ–≤–æ—Ä' do
  p –ü—ä—Ä–≤–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç, –∏–Ω–∞—á–µ –≤—Ä–µ–º–µ–Ω–Ω–∏—è –Ω–∏–∑ –∫–∞—Ç–æ –≤—Ç–æ—Ä–∏ –≥—ä—Ä–º–∏

  example:
    fn substring_starting_from<'a>(text: &'a str, query: &str) -> &'a str {
        match text.find(query) {
            Some(index) => &text[index..],
            None => "",
        }
    }

    fn main() {
        let result = substring_starting_from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000", "—Ü–≤—è—Ç");
        println!("{}", result);

        let text = String::from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000");
        let result = substring_starting_from(&text, &String::from("—Ü–≤—è—Ç"));
        println!("{}", result);
    }

= slide '–í—ä–ø—Ä–æ—Å' do
  p –ê –∞–∫–æ –∏–º–∞–º–µ —Å–∞–º–æ —Å—Ç–∞—Ç–∏—á–Ω–∏ –Ω–∏–∑–æ–≤–µ?

  example:
    fn substring_starting_from(text: &str, query: &str) -> &str {
        match text.find(query) {
            Some(index) => &text[index..],
            None => "",
        }
    }

    fn main() {
        let result = substring_starting_from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000", "—Ü–≤—è—Ç");
        println!("{}", result);
    }

= slide '–û—Ç–≥–æ–≤–æ—Ä' do
  p –î–æ—Å—Ç–∞ –≤–∞—Ä–∏–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—è—Ç (–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏—è —Å–ª—É—á–∞–π)

  example:
    fn substring_starting_from<'a>(text: &'a str, query: &str) -> &'a str {
    fn substring_starting_from<'a>(text: &'a str, query: &'a str) -> &'a str {

    fn substring_starting_from(text: &'static str, query: &str) -> &'static str {
    fn substring_starting_from(text: &'static str, query: &'static str) -> &'static str {

    // –∫–æ–º–ø–∏–ª–∞—Ü–∏–æ–Ω–Ω–∞ –≥—Ä–µ—à–∫–∞:
    // fn substring_starting_from(text: &str, query: &'static str) -> &'static str {

= slide '–í—ä–ø—Ä–æ—Å' do
  p –ê –∞–∫–æ –Ω–µ match-–≤–∞ –Ω–∏–∑–∞ –∏ –≤—ä—Ä–Ω–µ–º <code>""</code>?

  example:
    fn substring_starting_from(text: &str, query: &str) -> &str {
        match text.find(query) {
            Some(index) => &text[index..],
            None => "",
        }
    }

    fn main() {
        let result = substring_starting_from("–ï–¥–Ω–æ —Ñ–µ—Ä–∞—Ä–∏ —Å —Ü–≤—è—Ç #FF0000", "–ª–∞–º–±–æ—Ä–≥–∏–Ω–∏");
        println!("{}", result);
    }

= slide '–û—Ç–≥–æ–≤–æ—Ä' do
  p –°—ä—â–∏—Ç–µ. –ö–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ –≥–ª–µ–¥–∞ *–≤—Å–∏—á–∫–∏* –≤–∞—Ä–∏–∞–Ω—Ç–∏ –Ω–∞ match-–∞, –ø–æ–Ω–µ–∂–µ –Ω—è–º–∞ –∫–∞–∫ –¥–∞ –∑–Ω–∞–µ –∫–æ—è —â–µ –µ –∏—Å—Ç–∏–Ω—Å–∫–∞—Ç–∞ at runtime.

  example:
    fn substring_starting_from<'a>(text: &'a str, query: &str) -> &'a str {
    fn substring_starting_from<'a>(text: &'a str, query: &'a str) -> &'a str {

    fn substring_starting_from(text: &'static str, query: &str) -> &'static str {
    fn substring_starting_from(text: &'static str, query: &'static str) -> &'static str {

    // –∫–æ–º–ø–∏–ª–∞—Ü–∏–æ–Ω–Ω–∞ –≥—Ä–µ—à–∫–∞:
    // fn substring_starting_from(text: &str, query: &'static str) -> &'static str {

= slide '(–†–µ—Ç–æ—Ä–∏—á–µ–Ω) –í—ä–ø—Ä–æ—Å' do
  p –ö–∞–∫—ä–≤ –µ "–ø—Ä–∞–≤–∏–ª–Ω–∏—è –Ω–∞—á–∏–Ω"? –ú–∏–Ω–∏–º–∞–ª–Ω–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

  example:
    fn substring_starting_from(text: &'a str, query: &str) -> &'a str {
        match text.find(query) {
            Some(index) => &text[index..],
            None => "",
        }
    }

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä', 'Lifetime –∞–Ω–æ—Ç–∞—Ü–∏–∏ –∑–∞ —Ñ—É–Ω–∫—Ü–∏–∏' do
  p –í—Ä—ä–∑–∫–∞ –º–µ–∂–¥—É —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—Ç–µ

  example:
    // –†–µ–∑—É–ª—Ç–∞—Ç–∞ –µ —Å–≤—ä—Ä–∑–∞–Ω —Å –ø—ä—Ä–≤–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç
    fn substring_starting_from(text: &'a str, query: &str) -> &'a str {

    // –†–µ–∑—É–ª—Ç–∞—Ç–∞ –µ —Å–≤—ä—Ä–∑–∞–Ω –∏ —Å –¥–≤–∞—Ç–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ (–º–æ–∂–µ –∫–æ–π –¥–∞ –µ –æ—Ç –¥–≤–∞—Ç–∞ –¥–∞ –µ —Ä–µ–∑—É–ª—Ç–∞—Ç)
    fn longest(first: &'a str, second: &'a str) -> &'a str {

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä', 'Lifetime elision' do
  p –ó–∞ –≤—Å–µ–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç lifetime –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ —Å–µ –¥–æ–±–∞–≤—è lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä

  example:
    fn print(s: &str);                                  // elided
    fn print<'a>(s: &'a str);                           // expanded

    fn foo(x: (&u32, &u32), y: usize);                  // elided
    fn foo<'a, 'b>(x: (&'a u32, &'b u32), y: usize);    // expanded

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä', 'Lifetime elision' do
  p
    ' –ê–∫–æ –∑–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ –∏–º–∞ —Å–∞–º–æ –µ–¥–∏–Ω lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä (–µ–∫—Å–ø–ª–∏—Ü–∏—Ç–µ–Ω –∏–ª–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç),
      —Ç–æ–∑–∏ lifetime —Å–µ –Ω–∞–ª–∞–≥–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç–∏ lifetimes –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞

  example:
    fn substr(s: &str, until: usize) -> &str;                         // elided
    fn substr<'a>(s: &'a str, until: usize) -> &'a str;               // expanded

    fn split_at(s: &str, pos: usize) -> (&str, &str);                 // elided
    fn split_at<'a>(s: &'a str, pos: usize) -> (&'a str, &'a str);    // expanded

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä', 'Lifetime elision' do
  p
    ' –ê–∫–æ –ø—ä—Ä–≤–∏—è—Ç –∞—Ä–≥—É–º–µ–Ω—Ç –µ <code>&self</code> –∏–ª–∏ <code>&mut self</code>,
      –Ω–µ–≥–æ–≤–∏—è—Ç lifetime —Å–µ –Ω–∞–ª–∞–≥–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç–∏ lifetimes –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞

  example:
    fn get_mut(&mut self) -> &mut T;                                // elided
    fn get_mut<'a>(&'a mut self) -> &'a mut T;                      // expanded

    fn args(&mut self, args: &[T]) -> &mut Self;                    // elided
    fn args<'a, 'b>(&'a mut self, args: &'b [T]) -> &'a mut Self;   // expanded

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä', 'Lifetime elision' do
  p –í—ä–≤ –≤—Å–∏—á–∫–∏ –æ—Å—Ç–∞–Ω–∞–ª–∏ —Å–ª—É—á–∞–∏ –µ –≥—Ä–µ—à–∫–∞ –¥–∞ –ø—Ä–æ–ø—É—Å–Ω–µ–º lifetime-–∞.

  example:
    fn get_str() -> &str;                     // –∫–æ–º–ø. –≥—Ä–µ—à–∫–∞
    fn longest(x: &str, y: &str) -> &str;     // –∫–æ–º–ø. –≥—Ä–µ—à–∫–∞

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  list:
    –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ (const, static)
    –†–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ' do
  img src="images/universal_converter_box.png"

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ' do
  example:
    struct Celsius(f64);
    struct Fahrenheit(f64);
    struct Kelvin(f64);

    fn room_temperature() -> Fahrenheit {
        Fahrenheit(68.0)
    }

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ' do
  example:
    struct Celsius(f64);
    struct Fahrenheit(f64);
    struct Kelvin(f64);

    fn room_temperature() -> Fahrenheit {
        Fahrenheit(68.0)
    }

    fn energy_to_heat_water(from: Kelvin, to: Kelvin, mass: f64) -> f64 {
        // whatever
    }

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'From' do
  example:
    impl From<Celsius> for Kelvin {
        fn from(t: Celsius) -> Kelvin { Kelvin(t.0 + 273.15) }
    }

    impl From<Fahrenheit> for Celsius {
        fn from(t: Fahrenheit) -> Celsius { Celsius((t.0 - 32) / 1.8) }
    }

    impl From<Fahrenheit> for Kelvin {
        fn from(t: Fahrenheit) -> Kelvin { Kelvin::from(Celsius::from(t)) }
    }

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'From' do
  p –°–µ–≥–∞ –≤–µ—á–µ –º–æ–∂–µ–º –¥–∞ —Å–∏ —Å–≤–∞—Ä–∏–º —è–π—Ü–∞

  example:
    let e = energy_to_heat_water(Kelvin::from(room_temperature()), Kelvin::from(Celsius(100.0)), 1.0);
    println!("Heating water will cost {}J", e);

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'From' do
  example:
    pub trait From<T> {
        fn from(T) -> Self;
    }

  list:
    `From<T> for U` –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞ –æ—Ç `T` –¥–æ `U`
    `From<T> for T` –µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
    –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –Ω–µ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–æ–≤–∞–ª–∏

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'Into' do
  example:
    pub trait Into<T> {
        fn into(self) -> T;
    }

  list:
    `U::from(t)` –µ –¥—ä–ª–≥–æ –∑–∞ –ø–∏—Å–∞–Ω–µ
    –ó–∞—Ç–æ–≤–∞ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ "—Ä–µ—Ü–∏–ø—Ä–æ—á–µ–Ω" –º–µ—Ç–æ–¥
    `Into<U> for T` –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞ –æ—Ç `T` –¥–æ `U`
    `Into<T> for T` –µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ
    `Into<U> for T` —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–∞—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–º–µ `From<T> for U`
    –ü—Ä–∞–∫—Ç–∏–∫–∞—Ç–∞ –µ —Ä—ä—á–Ω–æ –¥–∞ —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ `From`

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'Into' do
  example:
    // –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ From
    let e = energy_to_heat_water(Kelvin::from(room_temperature()), Kelvin::from(Celsius(100.0)), 1.0);

    // –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ Into
    let e = energy_to_heat_water(room_temperature().into(), Celsius(100.0).into(), 1.0);

= slide '–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ', 'Generics' do
  p –ß–µ—Å—Ç–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞ –µ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–∞ –Ω–µ –≤–∑–∏–º–∞—Ç <code>T</code>, –∞ –Ω–µ—â–æ –∫–æ–µ—Ç–æ –º–æ–∂–µ –¥–∞ —Å–µ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞ –¥–æ <code>T</code>

  example:
    fn energy_to_heat_water<T1, T2>(from: T1, to: T2, mass: f64) -> f64  where
        T1: Into<Kelvin>,
        T2: Into<Kelvin>
    {
        // whatever
    }

    let e = energy_to_heat_water(room_temperature(), Celsius(100.0), 1.0);

= slide 'Iterator' do
  example:
    pub trait Iterator {
        /// –¢–∏–ø–∞ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ, –ø–æ –∫–æ–∏—Ç–æ —Ü–∏–∫–ª–∏–º
        type Item;

        /// –ú—ä—Ä–¥–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –Ω–∞–ø—Ä–µ–¥ –∏ –≤—Ä—ä—â–∞ —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç
        fn next(&mut self) -> Option<Self::Item>;

        // ...
    }

= slide 'Iterator', 'Fibonacci' do
  example:
    pub struct Fibonacci {
        previous: u32,
        current: u32,
    }

    impl Fibonacci {
        fn new() -> Self {
            Fibonacci { previous: 1, current: 0 }
        }
    }

= slide 'Iterator', 'Fibonacci' do
  example:
    impl Iterator for Fibonacci {
        type Item = u32;

        fn next(&mut self) -> Option<Self::Item> {
            let next = self.previous + self.current;

            self.previous = self.current;
            self.current = next;

            Some(next)
        }
    }

= slide 'Iterator', 'Fibonacci' do
  example:
    fn main() {
        let mut fibs = Fibonacci::new();

        for n in fibs.take(10) {
            print!("{}", n);
        }
    }

  pre.action
    ' 1 1 2 3 5 8 13 21 34 55

= slide 'Iterator', 'Fibonacci' do
  example:
    fn main() {
        let fibs = Fibonacci::new();
        let fibs_vector = fibs.take(10).collect::<Vec<u32>>();

        println!("{:?}", fibs_vector);
    }

  pre.action
    ' [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

= slide 'Iterator', 'Fibonacci' do
  example:
    fn main() {
        let fibs = Fibonacci::new().
            take(10).
            collect::<Vec<u32>>();

        println!("{:?}", fibs);
    }

  pre
    ' [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

= slide 'Iterator', 'TextInfo' do
  example:
    pub struct TextInfo<'a> {
        text: &'a str,
    }

= slide 'Iterator', 'TextInfo' do
  example:
    pub struct TextInfo { /* ... */ }

    struct SentenceIterator<'a> {
        chars: str::Chars<'a>,
        in_sentence: bool
    }

    impl<'a> SentenceIterator<'a> {
        fn new(s: &'a str) -> Self {
            Self {
                chars: s.chars(),
                in_sentence: false
            }
        }
    }

= slide 'Iterator', 'TextInfo' do
  example:
    impl<'a> Iterator for SentenceIterator<'a> {
        type Item = char;

        fn next(&mut self) -> Option<Self::Item> {
            for c in &mut self.chars {
                match c {
                    '?' | '!' | '.' => if self.in_sentence {
                        self.in_sentence = false;
                        return Some(c);
                    },
                    _ => if !c.is_whitespace() { self.in_sentence = true; }
                }
            }
            None
        }
    }

= slide 'Iterator', 'TextInfo' do
  example:
    pub fn emotion(&self) -> String {
        let mut exclamations = 0;
        let mut questions = 0;
        let mut full_stops = 0;

        for c in self.sentence_endings() {
            match c {
                '!' => exclamations += 1,
                '?' => questions    += 1,
                '.' => full_stops   += 1,
                _   => panic!(format!("Sentence ending was {}", c))
            }
        }

        // ...
    }

= slide 'Iterator', 'Methods' do
  p –ò—Ç–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –ø–æ–¥–¥—ä—Ä–∂–∞—Ç –Ω—è–∫–æ–∏ –∏–∑–≤–µ—Å—Ç–Ω–∏ –º–µ—Ç–æ–¥–∏ –æ—Ç —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ:

  ul
    li <code>count</code>
    li <code>enumerate</code>
    li <code>for_each</code>
    li <code>map</code>
    li <code>filter</code>
    li <code>fold</code>
    li <code>take</code>
    li <code>skip</code>
    li <code>nth</code>
    li <code>zip</code>
    li ...

= slide 'Iterator', 'enumerate' do
  p –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ <code>enumerate</code> –≤–º–µ—Å—Ç–æ –±—Ä–æ—è—á–∏

  example:
    for (i, element) in ['a', 'b', 'c'].into_iter().enumerate() {
        println!("arr[{}] = {}", i, element);
    }

  pre.action
    ' arr[0] = a
      arr[1] = b
      arr[2] = c

= slide 'Iterator', 'map' do
  p –ü—Ä–∏–µ–º–∞ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—è—Ç–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞ –≤—Å–µ–∫–∏ –µ–ª–µ–º–µ–Ω—Ç –æ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞

  example:
    fn transform(ch: char) -> char {
        // –†–∞–±–æ—Ç–∏ –ø—Ä–∞–≤–∏–ª–Ω–æ —Å–∞–º–æ –∑–∞ ascii —Å–∏–º–≤–æ–ª–∏
        (ch as u8 + 1) as char
    }

    for element in vec!['a', 'b', 'c'].into_iter().map(transform) {
        println!("{}", element);
    }

  pre.action
    ' b
      c
      d

= slide 'Iterator', 'filter' do
  p –§–∏–ª—Ç—Ä–∏—Ä–∞ –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ –Ω–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞, –∫–∞—Ç–æ –ø—Ä–µ–º–∞—Ö–≤–∞ —Ç–µ–∑–∏ –∫–æ–∏—Ç–æ –Ω–µ –æ—Ç–≥–æ–≤–∞—Ä—è—Ç –Ω–∞ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞

  example:
    fn predicate(num: &u32) -> bool {
        num.is_power_of_two()
    }

    for element in vec![1, 2, 3, 4, 5, 6, 7, 8].into_iter().filter(predicate) {
        println!("{}", element);
    }

  pre.action
    ' 1
      2
      4
      8

= slide 'Iterator', 'fold' do
  p '–°–º–∞—á–∫–≤–∞' —Å—Ç–æ–π–Ω–æ—Å—Ç–∏—Ç–µ –Ω–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –≤ –µ–¥–Ω–∞

  example:
    fn multiply(acc: u32, num: u32) -> u32 {
        acc * num
    }

    let factorial = vec![1, 2, 3, 4].into_iter().fold(1, multiply);

    println!("{}", factorial);

  pre.action
    ' 24

= slide 'Iterator', 'closures' do
  p –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–æ –∏–º–∞ –ø–æ-–ª–µ—Å–µ–Ω –Ω–∞—á–∏–Ω –∑–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ, —á—Ä–µ–∑ closures

= slide 'Iterator', 'closures' do
  example:
    for element in vec![5, 10, 15].into_iter().map(|x| x/5) {
        println!("{}", element);
    }

  pre.action
    ' 1
      2
      3

= slide 'Iterator', '–ú—ä—Ä–∑–µ–ª–∏–≤–æ—Å—Ç' do
  p –ò—Ç–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ —Å–∞ –º—ä—Ä–∑–µ–ª–∏–≤–∏, —Ç.–µ –Ω–µ –ø—Ä–∞–≤—è—Ç –Ω–∏—â–æ –¥–æ–∫–∞—Ç–æ –Ω–µ –∏–∑–≤–∏–∫–≤–∞–º–µ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–∞—â–∞ —Ñ—É–Ω–∫—Ü–∏—è –∏–ª–∏ <code>next</code>

= slide 'Iterator', '–ú—ä—Ä–∑–µ–ª–∏–≤–æ—Å—Ç' do
  example:
    fn main() {
        [1, 2, 3, 4].into_iter().take(10);
    }

  pre
    ' warning: unused `std::iter::Take` which must be used:
      iterator adaptors are lazy and do nothing unless consumed
      --> src/main.rs:2:5
        |
      2 |     [1, 2, 3, 4].into_iter().take(10);
        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        |
        = note: #[warn(unused_must_use)] on by default

= slide 'Iterator', '–ú—ä—Ä–∑–µ–ª–∏–≤–æ—Å—Ç' do
  ul
    li <code>next</code>
    li <code>collect</code>
    li <code>fold</code>
    li ...

= slide '–°–ø–µ—Ü–∏–∞–ª–Ω–∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏' do
  list:
    <code>IntoIterator</code>
    <code>ExactSizeIterator</code>
    <code>DoubleEndedIterator</code>

= slide 'IntoIterator' do
  example:
    pub trait IntoIterator {
        /// –¢–∏–ø–∞ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ, –ø–æ –∫–æ–∏—Ç–æ —Ü–∏–∫–ª–∏–º
        type Item;

        /// –í –∫–∞–∫—ä–≤ –∏—Ç–µ—Ä–∞—Ç–æ—Ä –≥–æ –ø—Ä–µ–≤—Ä—ä—â–∞–º–µ?
        type IntoIter: Iterator<Item=Self::Item>;

        /// –°—ä–∑–¥–∞–≤–∞–º–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä –æ—Ç —Å—Ç–æ–π–Ω–æ—Å—Ç
        fn into_iter(self) -> Self::IntoIter;
    }

= slide 'IntoIterator' do
  p –ò–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω –µ –∑–∞ –≤—Å–∏—á–∫–∏ —Ç–∏–ø–æ–≤–µ –∫–æ–∏—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç <code>trait Iterator</code>

  example:
    impl<I: Iterator> IntoIterator for I {
        type Item = I::Item;
        type IntoIter = I;

        fn into_iter(self) -> I {
            self
        }
    }

= slide 'IntoIterator' do
  p –ù–æ –∑–∞—â–æ?? ü§î

= slide 'IntoIterator', 'for-loop' do
  div style="display: flex; flex-direction: row; justify-content: center"
    div style="width: 100%; padding: 10px; border-right: 1px solid gray;"
      example:
        let values = vec![1, 2, 3, 4, 5];

        for x in values {
            println!("{}", x);
        }
    div style="width: 100%; padding: 10px 10px 10px 40px;"
      example:
        let values = vec![1, 2, 3, 4, 5];

        {
            let mut iter = IntoIterator::into_iter(values);
            loop {
                match iter.next() {
                    Some(val) => {
                        let x = val;
                        { println!("{}", x); };
                    }
                    None => break,
                };
            }
        }

= slide 'IntoIterator', 'Fibonacci' do
  example:
    // –ù–µ–∫–∞ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á–µ –Ω—è–∫–∞–∫–≤–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–∏ –µ –¥–∞–ª–∞ —Ç–∞–∑–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
    // –∏ —á–∏—Å–ª–∞—Ç–∞ –≤ –Ω–µ—è —Å–∞ –∫–æ—Ä–µ–∫—Ç–Ω–∏
    struct FibNums(u32, u32);

    impl IntoIterator for FibNums {
        type Item = u32;
        type IntoIter = Fibonacci;

        fn into_iter(self) -> Self::IntoIter {
            Fibonacci {
                previous: self.0,
                current: self.1
            }
        }
    }

= slide 'IntoIterator', 'Fibonacci' do
  p –¢–æ–≥–∞–≤–∞ –º–æ–∂–µ –¥–∞ –∑–∞–ø–æ—á–Ω–µ–º —Ü–∏–∫—ä–ª–∞ –æ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ —á–∏—Å–ª–∞.

  example:
    for n in FibNums(5, 8).into_iter().take(10) {
        println!("{}", n);
    }

= slide 'IntoIterator', 'Fibonacci' do
  p
    ' –ì–æ—Ä–Ω–∏—è—Ç –ø—Ä–∏–º–µ—Ä –º–æ–∂–µ –¥–∞ —Å–µ –ø–æ—Å—Ç–∏–≥–Ω–µ –∏ —Å –Ω–æ—Ä–º–∞–ª–µ–Ω from –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä, –Ω–æ
      –Ω—è–º–∞—à–µ –¥–∞ –º–æ–∂–µ –¥–∞ —Å–µ –∏–∑–ø—ä–ª–Ω–∏ —Å–ª–µ–¥–Ω–∏—è—Ç –∫–æ–¥:

  example:
    for n in FibNums(5, 8) {
        println!("{}", n);
    }

  p K–∞–∫–≤–æ —â–µ –Ω–∞–ø—Ä–∞–≤–∏ —Ç–æ–∑–∏ –ø—Ä–∏–º–µ—Ä?

= slide 'IntoIterator', 'Fibonacci' do
  p –©–µ –ø—Ä–∏–Ω—Ç–∏—Ä–∞ —á–∏—Å–ª–∞ –¥–æ–∫–∞—Ç–æ –Ω–µ –ø–æ–ª—É—á–∏–º

  pre
    thread 'main' panicked at 'attempt to add with overflow'

= slide 'IntoIterator' do
  list:
    –ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ...
    ... –∏–ª–∏ –ø—ä–∫ –Ω–µ —á–∞–∫ —Ç–æ–ª–∫–æ–≤–∞
    –ù–µ–∫–∞ –≤–∏–¥–∏–º –ø–æ-–ø–æ–ª–µ–∑–Ω–∏ –ø—Ä–∏–º–µ—Ä–∏

= slide 'IntoIterator', 'Vector' do
  example:
    impl<T> IntoIterator for Vec<T>
    impl<'a, T> IntoIterator for &'a Vec<T>
    impl<'a, T> IntoIterator for &'a mut Vec<T>

  p –¢–µ–∑–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–∏ —â–µ –≤—Ä—ä—â–∞—Ç —Å—ä–æ—Ç–≤–µ—Ç–Ω–æ

  example:
    fn into_iter(self) -> std::vec::IntoIter<T>
    fn into_iter(self) -> std::slice::Iter<'a, T>
    fn into_iter(self) -> std::slice::IterMut<'a, T>

  p
    ' –í—Å—è–∫–∞ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ç–µ —Å—ä–¥—ä—Ä–∂–∞ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∫—ä–º —Ç–µ–∫—É—â–∏—Ç–µ –µ–ª–µ–º–µ–Ω—Ç–∏.
      –í—ä—Ç—Ä–µ—à–Ω–æ <code>into_iter</code> –∑–∞ <code>Iter</code> –∏ <code>IterMut</code> –∏–∑–ø–æ–ª–∑–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏—Ç–µ
      <code>iter</code> –∏ <code>iter_mut</code> –∫–æ–∏—Ç–æ —Å–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏ –æ—Ç lifetimes,
      –∑–∞—Ç–æ–≤–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏—Ç–µ –Ω–µ –∂–∏–≤–µ—è—Ç –ø–æ-–¥—ä–ª–≥–æ –æ—Ç –≤–µ–∫—Ç–æ—Ä–∞.

= slide 'IntoIterator', 'Vector' do
  div style="display: flex; flex-direction: row; justify-content: center"
    div style="width: 100%; padding: 10px; border-right: 1px solid gray;"
      example:
        for element in vec.into_iter() {}
        for element in vec.iter() {}
        for element in vec.iter_mut() {}
    div style="width: 100%; padding: 10px 10px 10px 40px;"
      example:
        for element in vec {}
        for element in &vec {}
        for element in &mut vec {}

= slide 'ExactSizeIterator' do
  p –ù—è–∫–æ–∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏ –∑–Ω–∞—è—Ç –∫–æ–ª–∫–æ –ø—ä—Ç–∏ —â–µ –∏—Ç–µ—Ä–∏—Ä–∞—Ç

  example:
    pub trait ExactSizeIterator: Iterator {
        fn len(&self) -> usize { ... }
        fn is_empty(&self) -> bool { ... }
    }

= slide 'ExactSizeIterator' do
  p –ù–∞–ø—Ä–∏–º–µ—Ä –≤—Å—è–∫–∞ –∫—Ä–∞–π–Ω–∞ –æ–±–ª–∞—Å—Ç –∑–Ω–∞–µ –∫–æ–ª–∫–æ –ø—ä—Ç–∏ —â–µ —Å–µ –∏—Ç–µ—Ä–∏—Ä–∞

  example:
    let five = 0..5;

    assert_eq!(5, five.len());

= slide 'DoubleEndedIterator' do
  p –ü–æ–Ω—è–∫–æ–≥–∞ —Å–∞ –Ω–∏ –∏–∑–≤–µ—Å—Ç–Ω–∏ –¥–≤–∞—Ç–∞ –∫—Ä–∞—è –Ω–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –∏ —Å—ä–æ—Ç–≤–µ—Ç–Ω–æ –º–æ–∂–µ –¥–∞ –∏—Ç–µ—Ä–∏—Ä–∞–º–µ –∏ –æ—Ç –¥–≤–µ—Ç–µ —Å—Ç—Ä–∞–Ω–∏

  example:
    pub trait DoubleEndedIterator: Iterator {
        fn next_back(&mut self) -> Option<Self::Item>;

        fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>
        where
            P: FnMut(&Self::Item) -> bool,
        { ... }
    }

= slide 'DoubleEndedIterator' do
  p –ï–¥–∏–Ω —Ç–∞–∫—ä–≤ –ø—Ä–∏–º–µ—Ä —Å–∞ –≤–µ–∫—Ç–æ—Ä–∏—Ç–µ

  example:
    let numbers = vec![1, 2, 3, 4];

    let mut iter = numbers.into_iter();

    assert_eq!(Some(1), iter.next());
    assert_eq!(Some(4), iter.next_back());
    assert_eq!(Some(3), iter.next_back());
    assert_eq!(Some(2), iter.next());
    assert_eq!(None, iter.next());
    assert_eq!(None, iter.next_back());

= slide 'DoubleEndedIterator' do
  p –¢–æ–∑–∏ —Ç–∏–ø –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∏ –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ rev –º–µ—Ç–æ–¥–∞ –Ω–∞ Iterator

  example:
    let a = vec![1, 2, 3];

    let mut iter = a.into_iter().rev();

    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), None);
