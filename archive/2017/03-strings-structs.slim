= slide '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∏ –Ω–µ—â–∞' do
  list:
    –†–µ–≥–∏—Å—Ç—Ä–∏—Ä–∞–π—Ç–µ —Å–µ –≤ [https://fmi.rust-lang.bg](https://fmi.rust-lang.bg)!
    –ö–∞—á–µ—Ç–µ —Å–∏ —Å–Ω–∏–º–∫–∞! (+1 —Ç–æ—á–∫–∏)
    –ò–Ω—Å—Ç–∞–ª–∏—Ä–∞–π—Ç–µ —Å–∏ Rust (+1 —Ç–æ—á–∫–∏) [https://fmi.rust-lang.bg/topics/2](https://fmi.rust-lang.bg/topics/2)

= slide '–ü—Ä–µ–≥–æ–≤–æ—Ä' do
  list:
    –ö–æ—Ä—Ç–µ–∂–∏ (tuples)
    Stack & Heap
    –°–æ–±—Å—Ç–≤–µ–Ω–æ—Å—Ç (3 –ø—Ä–∞–≤–∏–ª–∞)
    –ù–∏–∑–æ–≤–µ (2 –≤–∏–¥–∞: –Ω–∞ —Å—Ç–µ–∫–∞ –∏ –≤ –¥–∏–Ω–∞–º–∏—á–Ω–∞—Ç–∞ –ø–∞–º–µ—Ç)
    –ü—Ä–∏—Å–≤–æ—è–≤–∞–Ω–µ (–ø—Ä–µ–º–µ—Å—Ç–≤–∞–Ω–µ –∏–ª–∏ –∫–æ–ø–∏—Ä–∞–Ω–µ)
    –°–æ–±—Å—Ç–≤–µ–Ω–æ—Å—Ç –ø—Ä–∏ –≤–∏–∫–∞–Ω–µ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏
    –ó–∞–µ–º–∞–Ω–µ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
    –ü—Å–µ–≤–¥–æ–Ω–∏–º–∏ (2 –ø—Ä–∞–≤–∏–ª–∞)

= slide '–°—Ç—Ä–∞–Ω–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∞–ª–∞—Ç–∞ –ª–µ–∫—Ü–∏—è', '(–Ω–µ—â–∞, –∫–æ–∏—Ç–æ –∏–∑–Ω–µ–Ω–∞–¥–∞—Ö–∞ –ê–Ω–¥—Ä–µ–π)' do
  example:
    let r;
    {
        r = String::new("foobar");
    }
    println!("{}", r);

= slide '–°—Ç—Ä–∞–Ω–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∞–ª–∞—Ç–∞ –ª–µ–∫—Ü–∏—è', '(–Ω–µ—â–∞, –∫–æ–∏—Ç–æ –∏–∑–Ω–µ–Ω–∞–¥–∞—Ö–∞ –ê–Ω–¥—Ä–µ–π)' do
  example:
    let x;
    println!("{}", x = 3); // wat

= slide '–°—Ç—Ä–∞–Ω–Ω–æ—Å—Ç–∏ –æ—Ç –º–∏–Ω–∞–ª–∞—Ç–∞ –ª–µ–∫—Ü–∏—è', '(–Ω–µ—â–∞, –∫–æ–∏—Ç–æ –∏–∑–Ω–µ–Ω–∞–¥–∞—Ö–∞ —Ü–µ–ª–∏—è –µ–∫–∏–ø)' do
  example:
    println!("{x} {y} {z}", x = 3, z = 1, y = 2);

= slide 'rustc 1.21.0 üéâ' do
  list:
    –ù–æ–≤–∞ –≤–µ—Ä—Å–∏—è –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞
    <code>rustup update</code>

= slide '–ú–∞—Å–∏–≤–∏' do
  example:
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    let elem = a[2];
    println!("{}", elem);   // 3

  list:
    —Ç–∏–ø <code>[T; n]</code>
    —Ñ–∏–∫—Å–∏—Ä–∞–Ω–∞ –≥–æ–ª–µ–º–∏–Ω–∞ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –∫–æ–º–ø–∏–ª–∞—Ü–∏—è
    –≥–æ–ª–µ–º–∏–Ω–∞—Ç–∞ –µ —á–∞—Å—Ç –æ—Ç —Ç–∏–ø–∞ - <code>[T; 3]</code> –∏ <code>[T; 5]</code> —Å–∞ —Ä–∞–∑–ª–∏—á–Ω–∏
    –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è—Ç–∞ –∑–∞–ø–æ—á–≤–∞ –æ—Ç 0
    –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –ø–æ–¥–∞–¥–µ–Ω–∏—è—Ç –∏–Ω–¥–µ–∫—Å –µ –≤–∞–ª–∏–¥–µ–Ω

= slide '–ú–∞—Å–∏–≤–∏', '–ú–Ω–æ–≥–æ–∏–∑–º–µ—Ä–Ω–∏ –º–∞—Å–∏–≤–∏' do
  example:
    let a: [[i32; 5]; 3] = [
        [01, 02, 03, 04, 05],
        [11, 12, 13, 14, 15],
        [21, 22, 23, 24, 25],
    ];

    let elem_1_2 = a[1][2];
    println!("{}", elem_1_2);   // ?

= slide '–ú–∞—Å–∏–≤–∏', '–ü—Ä–æ–ø—É—Å–∫–∞–Ω–µ –Ω–∞ —Ç–∏–ø–∞' do
  example:
    // –∞–∫–æ —Ä–∞–±–æ—Ç–∏ - –¥–æ–±—Ä–µ
    let a = [1, 2, 3, 4, 5];

    // –∞–∫–æ –Ω–µ - —Ç—Ä—è–±–≤–∞ –¥–∞ –∫–∞–∂–µ–º —Ç–∏–ø–∞ –Ω–∞ –ø–æ–Ω–µ –µ–¥–∏–Ω –µ–ª–µ–º–µ–Ω—Ç
    let a = [1_i32, 2, 3, 4, 5];
    let a = [1, 2, 3_i32, 4, 5];
    let a = [1, 2, 3, 4, 5_i32];

    let a = [
        [01, 02, 03, 04, 05],
        [11, 12, 13, 14, 15],
        [21, 22, 23, 24, 25_i32],
    ];

= slide '–î–∏–Ω–∞–º–∏—á–Ω–∏ –º–∞—Å–∏–≤–∏', '–í–µ–∫—Ç–æ—Ä–∏' do
  example:
    let a = vec![1, 2, 3, 4, 5];

    let elem = a[2];
    println!("{}", elem);   // 3

  list:
    —Ç–∏–ø <code>Vec&lt;T&gt;</code>
    –∞–ª–æ–∫–∏—Ä–∞ —Å–µ –≤ –¥–∏–Ω–∞–º–∏—á–Ω–∞—Ç–∞ –ø–∞–º–µ—Ç
    –ø—Ä–æ–º–µ–Ω–ª–∏–≤ –±—Ä–æ–π –µ–ª–µ–º–µ–Ω—Ç–∏ - –º–æ–∂–µ–º –¥–∞ –¥–æ–±–∞–≤—è–º–µ –∏–ª–∏ –ø—Ä–µ–º–∞—Ö–≤–∞–º–µ
    –º–∞–∫—Ä–æ <code>vec!</code> –ø–æ–∑–≤–æ–ª—è–≤–∞ –ª–µ—Å–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–µ
    –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –ø–æ–¥–∞–¥–µ–Ω–∏—è—Ç –∏–Ω–¥–µ–∫—Å –µ –≤–∞–ª–∏–¥–µ–Ω

= slide '–î–∏–Ω–∞–º–∏—á–Ω–∏ –º–∞—Å–∏–≤–∏', 'vec!' do
  example:
    let a = vec![1, 2, 3, 4, 5];

  p –ï–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ –Ω–∞

  example:
    let a = {
        let mut tmp = Vec::new();
        tmp.push_back(1);
        tmp.push_back(2);
        tmp.push_back(3);
        tmp.push_back(4);
        tmp.push_back(5);
        tmp
    };

= slide '–î–∏–Ω–∞–º–∏—á–Ω–∏ –º–∞—Å–∏–≤–∏', '–†–∞–∑–ø–æ–ª–∞–≥–∞–Ω–µ –≤ –ø–∞–º–µ—Ç—Ç–∞' do
  img src="images/vec_memory.png"

= slide '–í–∑–∏–º–∞–Ω–µ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç' do
  example:
    let v = vec![String::from("–±–∞–±–∞"), String::from("–¥—è–¥–æ")];

    let baba = v[0];    // –≥—Ä–µ—à–∫–∞, String –Ω–µ –µ Copy

= slide '–í–∑–∏–º–∞–Ω–µ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç' do
  example:
    let v = vec![String::from("–±–∞–±–∞"), String::from("–¥—è–¥–æ")];

    let baba = &v[0];
    let dqdo = &v[1];
    // let vnuche = &v[2]; // –≥—Ä–µ—à–∫–∞ –ø—Ä–∏ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ

= slide '–í–∑–∏–º–∞–Ω–µ –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç' do
  example:
    let v = vec![String::from("–±–∞–±–∞"), String::from("–¥—è–¥–æ")];

    let baba = &v[0];
    let dqdo = &v[1];

    v.push_back(String::from("–≤–Ω—É—á–µ"));   // –≥—Ä–µ—à–∫–∞

= slide '–ó–∞–µ–º–∞–Ω–µ –Ω–∞ —á–∞—Å—Ç –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∞' do
  p –ú–æ–∂–µ–º –¥–∞ –∑–∞–µ–º–∞–º–µ –æ—Ç–¥–µ–ª–Ω–∏ —á–∞—Å—Ç–∏ –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –∏ –∫–æ—Ä—Ç–µ–∂–∏

  example:
    let x = (1, 2);

    let r1 = &x;
    let r2 = &x.0;
    let r3 = &x.1;

= slide '–ó–∞–µ–º–∞–Ω–µ –Ω–∞ —á–∞—Å—Ç –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∞' do
  p –û—Ç–¥–µ–ª–Ω–∏—Ç–µ —á–∞—Å—Ç–∏ —Å–µ —Å—á–∏—Ç–∞—Ç –∫–∞—Ç–æ –æ—Ç–¥–µ–ª–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –æ—Ç borrow checker-a

  example:
    let mut x = (1, 2);

    let r1 = &mut x.0;
    let r2 = &mut x.1;

    let r1 = &mut x.0;
    let r2 = &mut x.0;  // –≥—Ä–µ—à–∫–∞

= slide '–ó–∞–µ–º–∞–Ω–µ –Ω–∞ —á–∞—Å—Ç –æ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä–∞' do
  p –ù–æ —Å–µ —Å—á–∏—Ç–∞—Ç –∏ –∫–∞—Ç–æ –∑–∞–µ–º–∞–Ω–µ –Ω–∞ —Ü—è–ª–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

  example:
    let mut x = (1, 2);

    let r1 = &x.0;
    let r2 = &mut x;  // –≥—Ä–µ—à–∫–∞

    let r1 = &mut x.0;
    let r2 = &x       // –≥—Ä–µ—à–∫–∞

= slide '–ó–∞–µ–º–∞–Ω–µ –Ω–∞ —á–∞—Å—Ç –æ—Ç –º–∞—Å–∏–≤' do
  example:
    let mut a = [String::from("–±–∞–±–∞"), String::from("–¥—è–¥–æ")];

    let baba = &mut a[0];
    let dqdo = &mut a[1];   // ?

= slide '–ó–∞–µ–º–∞–Ω–µ –Ω–∞ —á–∞—Å—Ç –æ—Ç –º–∞—Å–∏–≤', '–†–µ–∑–µ–Ω–∏' do
  img src="images/rezeni.jpg"

= slide '–†–µ–∑–µ–Ω–∏', '(Slices)' do
  example:
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];

    println!("{} {}", hello, world);

  list:
    —Ç–∏–ø <code>&[T]</code>, –∑–∞ —Ä–µ–∑–µ–Ω –æ—Ç –º–∞—Å–∏–≤
    —Ç–∏–ø <code>&str</code>, –∑–∞ —Ä–µ–∑–µ–Ω –æ—Ç –Ω–∏–∑

= slide '–†–µ–∑–µ–Ω–∏', '(Slices)' do
  img src="images/trpl04-06.png"

= slide '–†–µ–∑–µ–Ω–∏', '(Slices)' do
  example:
    let s = String::from("hello");
    let len = s.len();

    let slice = &s[0..2];
    let slice = &s[..2];

    let slice = &s[3..len];
    let slice = &s[3..];

    let slice = &s[..];

= slide '–†–µ–∑–µ–Ω–∏', '(Slices)' do
  example:
    fn first_word(s: &String) -> &str {
        let mut i = 0;

        for byte in s.bytes() {
            if byte == b' ' {
                return &s[0..i];
            }
            i += 1;
        }

        &s[..]
    }

= slide '–†–µ–∑–µ–Ω–∏', '(Slices)' do
  p –ö–∞–∫–≤–æ —Å—Ç–∞–≤–∞, –∞–∫–æ –Ω–µ –µ –ø—Å–µ–≤–¥–æ–Ω–∏–º?

  example:
    let s = String::from("hello world");
    let hello = s[0..5];

    println!("{}", hello);

  ' <pre>
    error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied
    --> src/main.rs:3:9
      |
    3 |     let hello = s[0..5];
      |         ^^^^^ `str` does not have a constant size known at compile-time
      |
      = help: the trait `std::marker::Sized` is not implemented for `str`
      = note: all local variables must have a statically known size
    </pre>

= slide '–°–º–µ—Å–≤–∞–Ω–µ –Ω–∞ —Ç–∏–ø–æ–≤–µ' do
  example:
    fn first_word(s: &String) -> &str { /* ... */ }

  example:
    fn first_word(s: &str) -> &str { /* ... */ }

= slide '–°–º–µ—Å–≤–∞–Ω–µ –Ω–∞ —Ç–∏–ø–æ–≤–µ' do
  example:
    fn main() {
        let hello = String::from("hello world");
        let word = first_word(&hello[..]); // slice –æ—Ç String

        let hello = "hello world";
        let word = first_word(&hello[..]); // slice –æ—Ç &str
        let word = first_word(hello);      // –¥–∏—Ä–µ–∫—Ç–Ω–æ –ø–æ–¥–∞–≤–∞–º–µ &str
    }

= slide 'Deref coercion' do
  p –ü—Ä–∞–≤–∏–ª–∞ –∑–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –æ—Ç –µ–¥–∏–Ω —Ç–∏–ø –ø—Å–µ–≤–¥–æ–Ω–∏–º –¥–æ –¥—Ä—É–≥
  p –ò–∑–ø–æ–ª–∑–≤–∞—Ç —Å–µ —Å–∞–º–æ –ø—Ä–∏:
  ul
    li –ø–æ–¥–∞–≤–∞–Ω–µ –Ω–∞ –∞—Ä–≥—É–º–µ–Ω—Ç –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
    li –∏–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ –º–µ—Ç–æ–¥

  p.action –ü—Ä–∏–º–µ—Ä–∏
  list:
    <code>&[u32; 5]</code> -> <code>&[u32]</code>
    <code>&Vec&lt;u32&gt;</code> -> <code>&[u32]</code>
    <code>&String</code> -> <code>&str</code>

= slide '–°–º–µ—Å–≤–∞–Ω–µ –Ω–∞ —Ç–∏–ø–æ–≤–µ' do
  example:
    fn main() {
        let hello = String::from("hello world");
        let word = first_word(&hello);      // –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ –Ω–∞ &hello[..]
        let len = hello.len();              // –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ–Ω–≤–µ–Ω—Ç–∏—Ä–∞ –¥–æ &str –∏ –∏–∑–≤–∏–∫–≤–∞ –º–µ—Ç–æ–¥–∞ –º—É len

        let hello = "hello world";
        let word = first_word(hello);       // –¥–∏—Ä–µ–∫—Ç–Ω–æ –ø–æ–¥–∞–≤–∞–º–µ &str
        let len = hello.len();              // –¥–∏—Ä–µ–∫—Ç–Ω–æ –∏–∑–≤–∏–∫–≤–∞–º–µ –º–µ—Ç–æ–¥–∞ len
    }

= slide '–°—Ç–∞—Ç–∏—á–Ω–∏ –Ω–∏–∑–æ–≤–µ' do
  example:
    let s: &'static str = "Hello, world!";

= slide 'Structs' do
  example:
    struct User {
        username:      String,
        email:         String,
        sign_in_count: u64,
        active:        bool,
    }

= slide 'Structs' do
  example:
    fn main() {
        let baba = User {
            email:         String::from("baba@abv.bg"),
            username:      String::from("baba_1337"),
            active:        true,
            sign_in_count: 1,
        };

        println!("{:?}", baba); // –≥—Ä–µ—à–∫–∞, –∑–∞ –º–æ–º–µ–Ω—Ç–∞
    }

= slide 'Structs', '–∞—Ç—Ä–∏–±—É—Ç derive' do
  example:
    #[derive(Debug)]
    struct User {
        username:      String,
        email:         String,
        sign_in_count: u64,
        active:        bool,
    }

= slide 'Structs' do
  example:
    fn main() {
        let baba = User {
            email:         String::from("baba@abv.bg"),
            username:      String::from("baba_1337"),
            active:        true,
            sign_in_count: 1,
        };

        println!("{:?}", baba);
        // => User { username: "baba_1337", email: "baba@abv.bg", sign_in_count: 1, active: true }
    }

= slide 'Structs', 'field mutability' do
  example:
    let baba = User { /* ... */ };

    // baba.email = String::from("hackerman@l33t.hax"); // –≥—Ä–µ—à–∫–∞

    let mut baba = baba;

    baba.email = String::from("hackerman@l33t.hax");

= slide 'Structs', 'update syntax' do
  example:
    let hackerman = User {
        email:          String::from("hackerman@l33t.hax"),
        username:       String::from(""),
        active:         baba.active,
        sign_in_count:  baba.sign_in_count,
    };

    println!("{:?}", hackerman);
    // => User { username: "", email: "hackerman@l33t.hax", sign_in_count: 1, active: true }

= slide 'Structs', 'update syntax' do
  example:
    let hackerman = User {
        email:    String::from("hackerman@l33t.hax"),
        username: String::from(""),
        ..baba,
    };

    println!("{:?}", hackerman);
    // => User { username: "", email: "hackerman@l33t.hax", sign_in_count: 1, active: true }

= slide 'Tuple Structs', '(–∫–æ—Ä—Ç–µ–∂–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏? —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–∏ –∫–æ—Ä—Ç–µ–∂–∏?)' do
  example:
    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);

= slide 'Unit Structs' do
  example:
    struct Electron {} // –ü—Ä–∞–∑–Ω–∏ —Å–∫–æ–±–∏...
    struct Proton;     // ...–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–æ—á–∫–∞ –∏ –∑–∞–ø–µ—Ç–∞—è.

    // –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ —Å—ä—â–∞—Ç–∞ –Ω–æ—Ç–∞—Ü–∏—è –∫–æ–≥–∞—Ç–æ –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä–∞—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞.
    let x = Electron {};
    let y = Proton;
    // let z = Electron; // –≥—Ä–µ—à–∫–∞

  list:
    –ì–æ–ª–µ–º–∏–Ω–∞ 0 –±–∞–π—Ç–∞

= slide 'Structs: what about &str' do
  p –ê –∑–∞—â–æ –Ω–µ <code>&str</code> –≤–º–µ—Å—Ç–æ <code>String</code>?

  example:
    struct User {
        username:      &str, // ???
        email:         &str, // ???
        sign_in_count: u64,
        active:        bool,
    }

  ' <pre>
    error[E0106]: missing lifetime specifier
    --> src/main.rs:3:20
      |
    3 |     username:      &str,
      |                    ^ expected lifetime parameter

    ...
    </pre>

= slide 'Lifetimes' do
  p ... —Å–∞ –Ω–µ—â–∞, –∑–∞ –∫–æ–∏—Ç–æ —â–µ –≥–æ–≤–æ—Ä–∏–º –ø–æ—Å–ª–µ
  p –ü—Ä–æ—Å—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ <code>String</code> –∑–∞—Å–µ–≥–∞

= slide '–ú–µ—Ç–æ–¥–∏' do
  example:
    #[derive(Debug)]
    struct Rectangle {
        length: u32,
        width: u32,
    }

    fn main() {
        let r = Rectangle { length: 50, width: 30 };

        println!(
            "–ü–ª–æ—â—Ç–∞ –Ω–∞ –ø—Ä–∞–≤–æ—ä–≥—ä–ª–Ω–∏–∫–∞ –µ {}px¬≤",
            r.length * r.width
        );
    }

= slide '–ú–µ—Ç–æ–¥–∏' do
  example:
    #[derive(Debug)]
    struct Rectangle {
        length: u32,
        width: u32,
    }

    impl Rectangle {
        fn area(&self) -> u32 {
            self.length * self.width
        }
    }

= slide '–ú–µ—Ç–æ–¥–∏' do
  example:
    fn main() {
        let r = Rectangle { length: 50, width: 30 };

        println!(
            "–ü–ª–æ—â—Ç–∞ –Ω–∞ –ø—Ä–∞–≤–æ—ä–≥—ä–ª–Ω–∏–∫–∞ –µ {}px¬≤",
            r.area()
        );
    }

= slide '–ú–µ—Ç–æ–¥–∏', '–∫–∞–∫–≤–æ –µ self?' do
  example:
    impl Rectangle {
        fn area(self: &Rectangle) -> u32 {
            self.length * self.width
        }
    }

= slide '–ú–µ—Ç–æ–¥–∏', '–≤–∏–¥–æ–≤–µ –¥–µ—Ñ–∏–Ω–∏—Ü–∏–∏' do
  example:
    impl SomeStructType {
        fn method_borrows(&self) -> u32 { 42 }

        fn method_borrows_mutably(&mut self) -> u32 { 42 }

        fn method_takes_ownership(self) -> u32 { 42 }
    }

= slide '–ú–µ—Ç–æ–¥–∏', 'mutable borrow' do
  example:
    // impl std::string::String {
    fn push_str(&mut self, string: &str) {

    let mut s = String::from("hello");
    // let s2 = &mut s; // –≥—Ä–µ—à–∫–∞
    s.push_str(", world");

= slide '–ú–µ—Ç–æ–¥–∏', 'Deref coercion' do
  example:
    struct Point { x: f64, y: f64 };

    impl Point {
        fn distance(self: &Point, other: &Point) -> f64 {
            // ...
        }
    }

    p1.distance(&p2);
    (&&&p1).distance(&&&&&&p2);

= slide '–ú–µ—Ç–æ–¥–∏', 'Deref coercion' do
    table
      thead
        tr
          th Rust
          th colspan="2" C
      tbody
        tr
          td (&instance).field
          td (*(&instance)).field
          td instance->field
        tr
          td (&&&instance).field
          td (***(&&&instance)).field
          td (**(&&&instance))->field

= slide '–ê—Å–æ—Ü–∏–∏—Ä–∞–Ω–∏ –º–µ—Ç–æ–¥–∏' do
  example:
    #[derive(Debug)]
    struct User {
        username:      String,
        email:         String,
        sign_in_count: u64,
        active:        bool,
    }

= slide '–ê—Å–æ—Ü–∏–∏—Ä–∞–Ω–∏ –º–µ—Ç–æ–¥–∏' do
  example:
    impl User {
        fn new(username: &str, email: &str) -> User {
            User {
                username:      String::from(username),
                email:         String::from(email),
                sign_in_count: 0,
                active:        false,
            }
        }
    }

    fn main() {
        let gosho = User::new("~*-_Lo60-Go60_-*~", "go6enceto@abv.bg");
    }

= slide '–°—ä–∫—Ä–∞—Ç–µ–Ω —Å–∏–Ω—Ç–∞–∫—Å–∏—Å' do
  example:
    impl User {
        fn new(username: String, email: String) -> User {
            User {
                username,
                email,
                sign_in_count: 0,
                active:        false,
            }
        }
    }

= slide '–ú–µ—Ç–æ–¥–∏', '—Ç–∏–ø Self' do
  example:
    impl SomeLongStructNameThatWeDontWantToRepeat {
        fn new(username: String, email: String) -> Self {
            Self {
                username,
                email
            }
        }
    }

= slide '–ê—Å–æ—Ü–∏–∏—Ä–∞–Ω–∏ –º–µ—Ç–æ–¥–∏', '—Ñ–æ—Ä–º–∞–ª–Ω–æ –∏–∑–≤–∏–∫–≤–∞–Ω–µ –Ω–∞ –º–µ—Ç–æ–¥–∏' do
  example:
    fn main() {
        let r = Rectangle { length: 50, width: 30 };
        let area = Rectangle::area(&r);

        println!("–ü–ª–æ—â—Ç–∞ –Ω–∞ –ø—Ä–∞–≤–æ—ä–≥—ä–ª–Ω–∏–∫–∞ –µ {}px¬≤", area);
    }
